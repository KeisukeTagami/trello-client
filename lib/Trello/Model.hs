{-
   Trello

   This document describes the REST API of Trello as published by Trello.com.  - <a href='https://trello.com/docs/index.html' target='_blank'>Official Documentation</a>  - <a href='https://trello.com/docs/api' target='_blank'>The HTML pages that were scraped in order to generate this specification.</a>

   OpenAPI spec version: 2.0
   Trello API version: 1.0
   Generated by Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
-}

{-|
Module : Trello.Model
-}

{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveFoldable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE TypeFamilies #-}
{-# OPTIONS_GHC -fno-warn-unused-matches -fno-warn-unused-binds -fno-warn-unused-imports #-}

module Trello.Model where

import Trello.Core
import Trello.MimeTypes

import Data.Aeson ((.:),(.:!),(.:?),(.=))

import qualified Control.Arrow as P (left)
import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Base64 as B64
import qualified Data.ByteString.Char8 as BC
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (Typeable, TypeRep, typeOf, typeRep)
import qualified Data.Foldable as P
import qualified Data.HashMap.Lazy as HM
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Set as Set
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Time as TI
import qualified Lens.Micro as L
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH

import Control.Applicative ((<|>))
import Control.Applicative (Alternative)
import Data.Function ((&))
import Data.Monoid ((<>))
import Data.Text (Text)
import Prelude (($),(/=),(.),(<$>),(<*>),(>>=),(=<<),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty,maybe,pure,Monad,Applicative,Functor)

import qualified Prelude as P



-- * Parameter newtypes


-- ** ActionBefore
newtype ActionBefore = ActionBefore { unActionBefore :: Text } deriving (P.Eq, P.Show)

-- ** ActionFields
newtype ActionFields = ActionFields { unActionFields :: Text } deriving (P.Eq, P.Show)

-- ** ActionMember
newtype ActionMember = ActionMember { unActionMember :: Text } deriving (P.Eq, P.Show)

-- ** ActionMemberCreator
newtype ActionMemberCreator = ActionMemberCreator { unActionMemberCreator :: Text } deriving (P.Eq, P.Show)

-- ** ActionMemberCreatorFields
newtype ActionMemberCreatorFields = ActionMemberCreatorFields { unActionMemberCreatorFields :: Text } deriving (P.Eq, P.Show)

-- ** ActionMemberFields
newtype ActionMemberFields = ActionMemberFields { unActionMemberFields :: Text } deriving (P.Eq, P.Show)

-- ** ActionSince
newtype ActionSince = ActionSince { unActionSince :: Text } deriving (P.Eq, P.Show)

-- ** Actions2
newtype Actions2 = Actions2 { unActions2 :: Text } deriving (P.Eq, P.Show)

-- ** ActionsDisplay
newtype ActionsDisplay = ActionsDisplay { unActionsDisplay :: Text } deriving (P.Eq, P.Show)

-- ** ActionsEntities
newtype ActionsEntities = ActionsEntities { unActionsEntities :: Text } deriving (P.Eq, P.Show)

-- ** ActionsFormat
newtype ActionsFormat = ActionsFormat { unActionsFormat :: Text } deriving (P.Eq, P.Show)

-- ** ActionsLimit
newtype ActionsLimit = ActionsLimit { unActionsLimit :: Text } deriving (P.Eq, P.Show)

-- ** ActionsSince
newtype ActionsSince = ActionsSince { unActionsSince :: Text } deriving (P.Eq, P.Show)

-- ** Activity
newtype Activity = Activity { unActivity :: Text } deriving (P.Eq, P.Show)

-- ** AttachmentFields
newtype AttachmentFields = AttachmentFields { unAttachmentFields :: Text } deriving (P.Eq, P.Show)

-- ** Attachments
newtype Attachments = Attachments { unAttachments :: Text } deriving (P.Eq, P.Show)

-- ** Before
newtype Before = Before { unBefore :: Text } deriving (P.Eq, P.Show)

-- ** Board
newtype Board = Board { unBoard :: Text } deriving (P.Eq, P.Show)

-- ** BoardActionFields
newtype BoardActionFields = BoardActionFields { unBoardActionFields :: Text } deriving (P.Eq, P.Show)

-- ** BoardActions
newtype BoardActions = BoardActions { unBoardActions :: Text } deriving (P.Eq, P.Show)

-- ** BoardActionsDisplay
newtype BoardActionsDisplay = BoardActionsDisplay { unBoardActionsDisplay :: Text } deriving (P.Eq, P.Show)

-- ** BoardActionsEntities
newtype BoardActionsEntities = BoardActionsEntities { unBoardActionsEntities :: Text } deriving (P.Eq, P.Show)

-- ** BoardActionsFormat
newtype BoardActionsFormat = BoardActionsFormat { unBoardActionsFormat :: Text } deriving (P.Eq, P.Show)

-- ** BoardActionsLimit
newtype BoardActionsLimit = BoardActionsLimit { unBoardActionsLimit :: Text } deriving (P.Eq, P.Show)

-- ** BoardActionsSince
newtype BoardActionsSince = BoardActionsSince { unBoardActionsSince :: Text } deriving (P.Eq, P.Show)

-- ** BoardBackgrounds
newtype BoardBackgrounds = BoardBackgrounds { unBoardBackgrounds :: Text } deriving (P.Eq, P.Show)

-- ** BoardFields
newtype BoardFields = BoardFields { unBoardFields :: Text } deriving (P.Eq, P.Show)

-- ** BoardLists
newtype BoardLists = BoardLists { unBoardLists :: Text } deriving (P.Eq, P.Show)

-- ** BoardMemberships
newtype BoardMemberships = BoardMemberships { unBoardMemberships :: Text } deriving (P.Eq, P.Show)

-- ** BoardOrganization
newtype BoardOrganization = BoardOrganization { unBoardOrganization :: Text } deriving (P.Eq, P.Show)

-- ** BoardOrganizationFields
newtype BoardOrganizationFields = BoardOrganizationFields { unBoardOrganizationFields :: Text } deriving (P.Eq, P.Show)

-- ** BoardStars
newtype BoardStars = BoardStars { unBoardStars :: Text } deriving (P.Eq, P.Show)

-- ** Boards2
newtype Boards2 = Boards2 { unBoards2 :: Text } deriving (P.Eq, P.Show)

-- ** BoardsInvited
newtype BoardsInvited = BoardsInvited { unBoardsInvited :: Text } deriving (P.Eq, P.Show)

-- ** BoardsInvitedFields
newtype BoardsInvitedFields = BoardsInvitedFields { unBoardsInvitedFields :: Text } deriving (P.Eq, P.Show)

-- ** BoardsLimit
newtype BoardsLimit = BoardsLimit { unBoardsLimit :: Text } deriving (P.Eq, P.Show)

-- ** Card
newtype Card = Card { unCard :: Text } deriving (P.Eq, P.Show)

-- ** CardAttachmentFields
newtype CardAttachmentFields = CardAttachmentFields { unCardAttachmentFields :: Text } deriving (P.Eq, P.Show)

-- ** CardAttachments
newtype CardAttachments = CardAttachments { unCardAttachments :: Text } deriving (P.Eq, P.Show)

-- ** CardBoard
newtype CardBoard = CardBoard { unCardBoard :: Text } deriving (P.Eq, P.Show)

-- ** CardChecklists
newtype CardChecklists = CardChecklists { unCardChecklists :: Text } deriving (P.Eq, P.Show)

-- ** CardFields
newtype CardFields = CardFields { unCardFields :: Text } deriving (P.Eq, P.Show)

-- ** CardList
newtype CardList = CardList { unCardList :: Text } deriving (P.Eq, P.Show)

-- ** CardMemberFields
newtype CardMemberFields = CardMemberFields { unCardMemberFields :: Text } deriving (P.Eq, P.Show)

-- ** CardMembers
newtype CardMembers = CardMembers { unCardMembers :: Text } deriving (P.Eq, P.Show)

-- ** CardStickers
newtype CardStickers = CardStickers { unCardStickers :: Text } deriving (P.Eq, P.Show)

-- ** Cards2
newtype Cards2 = Cards2 { unCards2 :: Text } deriving (P.Eq, P.Show)

-- ** CardsLimit
newtype CardsLimit = CardsLimit { unCardsLimit :: Text } deriving (P.Eq, P.Show)

-- ** CardsPage
newtype CardsPage = CardsPage { unCardsPage :: Text } deriving (P.Eq, P.Show)

-- ** CheckItemFields
newtype CheckItemFields = CheckItemFields { unCheckItemFields :: Text } deriving (P.Eq, P.Show)

-- ** CheckItemStateFields
newtype CheckItemStateFields = CheckItemStateFields { unCheckItemStateFields :: Text } deriving (P.Eq, P.Show)

-- ** CheckItemStates
newtype CheckItemStates = CheckItemStates { unCheckItemStates :: Text } deriving (P.Eq, P.Show)

-- ** CheckItems
newtype CheckItems = CheckItems { unCheckItems :: Text } deriving (P.Eq, P.Show)

-- ** ChecklistFields
newtype ChecklistFields = ChecklistFields { unChecklistFields :: Text } deriving (P.Eq, P.Show)

-- ** Checklists2
newtype Checklists2 = Checklists2 { unChecklists2 :: Text } deriving (P.Eq, P.Show)

-- ** Color
newtype Color = Color { unColor :: Text } deriving (P.Eq, P.Show)

-- ** CustomBoardBackgrounds
newtype CustomBoardBackgrounds = CustomBoardBackgrounds { unCustomBoardBackgrounds :: Text } deriving (P.Eq, P.Show)

-- ** CustomEmoji
newtype CustomEmoji = CustomEmoji { unCustomEmoji :: Text } deriving (P.Eq, P.Show)

-- ** CustomStickers
newtype CustomStickers = CustomStickers { unCustomStickers :: Text } deriving (P.Eq, P.Show)

-- ** Display
newtype Display = Display { unDisplay :: Text } deriving (P.Eq, P.Show)

-- ** Entities
newtype Entities = Entities { unEntities :: Text } deriving (P.Eq, P.Show)

-- ** Field
newtype Field = Field { unField :: Text } deriving (P.Eq, P.Show)

-- ** Fields
newtype Fields = Fields { unFields :: Text } deriving (P.Eq, P.Show)

-- ** Filter
newtype Filter = Filter { unFilter :: Text } deriving (P.Eq, P.Show)

-- ** Format
newtype Format = Format { unFormat :: Text } deriving (P.Eq, P.Show)

-- ** Id
newtype Id = Id { unId :: Text } deriving (P.Eq, P.Show)

-- ** IdAction
newtype IdAction = IdAction { unIdAction :: Text } deriving (P.Eq, P.Show)

-- ** IdAttachment
newtype IdAttachment = IdAttachment { unIdAttachment :: Text } deriving (P.Eq, P.Show)

-- ** IdBoard
newtype IdBoard = IdBoard { unIdBoard :: Text } deriving (P.Eq, P.Show)

-- ** IdBoardBackground
newtype IdBoardBackground = IdBoardBackground { unIdBoardBackground :: Text } deriving (P.Eq, P.Show)

-- ** IdBoardStar
newtype IdBoardStar = IdBoardStar { unIdBoardStar :: Text } deriving (P.Eq, P.Show)

-- ** IdBoards
newtype IdBoards = IdBoards { unIdBoards :: Text } deriving (P.Eq, P.Show)

-- ** IdCard
newtype IdCard = IdCard { unIdCard :: Text } deriving (P.Eq, P.Show)

-- ** IdCards
newtype IdCards = IdCards { unIdCards :: Text } deriving (P.Eq, P.Show)

-- ** IdCheckItem
newtype IdCheckItem = IdCheckItem { unIdCheckItem :: Text } deriving (P.Eq, P.Show)

-- ** IdChecklist
newtype IdChecklist = IdChecklist { unIdChecklist :: Text } deriving (P.Eq, P.Show)

-- ** IdChecklistCurrent
newtype IdChecklistCurrent = IdChecklistCurrent { unIdChecklistCurrent :: Text } deriving (P.Eq, P.Show)

-- ** IdCustomEmoji
newtype IdCustomEmoji = IdCustomEmoji { unIdCustomEmoji :: Text } deriving (P.Eq, P.Show)

-- ** IdCustomSticker
newtype IdCustomSticker = IdCustomSticker { unIdCustomSticker :: Text } deriving (P.Eq, P.Show)

-- ** IdLabel
newtype IdLabel = IdLabel { unIdLabel :: Text } deriving (P.Eq, P.Show)

-- ** IdList
newtype IdList = IdList { unIdList :: Text } deriving (P.Eq, P.Show)

-- ** IdMember
newtype IdMember = IdMember { unIdMember :: Text } deriving (P.Eq, P.Show)

-- ** IdMembership
newtype IdMembership = IdMembership { unIdMembership :: Text } deriving (P.Eq, P.Show)

-- ** IdModels
newtype IdModels = IdModels { unIdModels :: Text } deriving (P.Eq, P.Show)

-- ** IdNotification
newtype IdNotification = IdNotification { unIdNotification :: Text } deriving (P.Eq, P.Show)

-- ** IdOrg
newtype IdOrg = IdOrg { unIdOrg :: Text } deriving (P.Eq, P.Show)

-- ** IdOrganization
newtype IdOrganization = IdOrganization { unIdOrganization :: Text } deriving (P.Eq, P.Show)

-- ** IdOrganizations
newtype IdOrganizations = IdOrganizations { unIdOrganizations :: Text } deriving (P.Eq, P.Show)

-- ** IdSavedSearch
newtype IdSavedSearch = IdSavedSearch { unIdSavedSearch :: Text } deriving (P.Eq, P.Show)

-- ** IdSession
newtype IdSession = IdSession { unIdSession :: Text } deriving (P.Eq, P.Show)

-- ** IdSticker
newtype IdSticker = IdSticker { unIdSticker :: Text } deriving (P.Eq, P.Show)

-- ** IdWebhook
newtype IdWebhook = IdWebhook { unIdWebhook :: Text } deriving (P.Eq, P.Show)

-- ** IxLastUpdate
newtype IxLastUpdate = IxLastUpdate { unIxLastUpdate :: Text } deriving (P.Eq, P.Show)

-- ** Key
newtype Key = Key { unKey :: Text } deriving (P.Eq, P.Show)

-- ** LabelFields
newtype LabelFields = LabelFields { unLabelFields :: Text } deriving (P.Eq, P.Show)

-- ** Labels2
newtype Labels2 = Labels2 { unLabels2 :: Text } deriving (P.Eq, P.Show)

-- ** LabelsLimit
newtype LabelsLimit = LabelsLimit { unLabelsLimit :: Text } deriving (P.Eq, P.Show)

-- ** Limit
newtype Limit = Limit { unLimit :: Text } deriving (P.Eq, P.Show)

-- ** ListFields
newtype ListFields = ListFields { unListFields :: Text } deriving (P.Eq, P.Show)

-- ** Lists2
newtype Lists2 = Lists2 { unLists2 :: Text } deriving (P.Eq, P.Show)

-- ** Member
newtype Member = Member { unMember :: Text } deriving (P.Eq, P.Show)

-- ** MemberActivity
newtype MemberActivity = MemberActivity { unMemberActivity :: Text } deriving (P.Eq, P.Show)

-- ** MemberCreator
newtype MemberCreator = MemberCreator { unMemberCreator :: Text } deriving (P.Eq, P.Show)

-- ** MemberCreatorFields
newtype MemberCreatorFields = MemberCreatorFields { unMemberCreatorFields :: Text } deriving (P.Eq, P.Show)

-- ** MemberFields
newtype MemberFields = MemberFields { unMemberFields :: Text } deriving (P.Eq, P.Show)

-- ** MemberVotedFields
newtype MemberVotedFields = MemberVotedFields { unMemberVotedFields :: Text } deriving (P.Eq, P.Show)

-- ** Members2
newtype Members2 = Members2 { unMembers2 :: Text } deriving (P.Eq, P.Show)

-- ** MembersInvited
newtype MembersInvited = MembersInvited { unMembersInvited :: Text } deriving (P.Eq, P.Show)

-- ** MembersInvitedFields
newtype MembersInvitedFields = MembersInvitedFields { unMembersInvitedFields :: Text } deriving (P.Eq, P.Show)

-- ** MembersLimit
newtype MembersLimit = MembersLimit { unMembersLimit :: Text } deriving (P.Eq, P.Show)

-- ** MembersVoted
newtype MembersVoted = MembersVoted { unMembersVoted :: Text } deriving (P.Eq, P.Show)

-- ** Memberships
newtype Memberships = Memberships { unMemberships :: Text } deriving (P.Eq, P.Show)

-- ** MembershipsMember
newtype MembershipsMember = MembershipsMember { unMembershipsMember :: Text } deriving (P.Eq, P.Show)

-- ** MembershipsMemberFields
newtype MembershipsMemberFields = MembershipsMemberFields { unMembershipsMemberFields :: Text } deriving (P.Eq, P.Show)

-- ** ModelTypes
newtype ModelTypes = ModelTypes { unModelTypes :: Text } deriving (P.Eq, P.Show)

-- ** MyPrefs
newtype MyPrefs = MyPrefs { unMyPrefs :: Text } deriving (P.Eq, P.Show)

-- ** NotificationBefore
newtype NotificationBefore = NotificationBefore { unNotificationBefore :: Text } deriving (P.Eq, P.Show)

-- ** NotificationFields
newtype NotificationFields = NotificationFields { unNotificationFields :: Text } deriving (P.Eq, P.Show)

-- ** NotificationMemberCreator
newtype NotificationMemberCreator = NotificationMemberCreator { unNotificationMemberCreator :: Text } deriving (P.Eq, P.Show)

-- ** NotificationMemberCreatorFields
newtype NotificationMemberCreatorFields = NotificationMemberCreatorFields { unNotificationMemberCreatorFields :: Text } deriving (P.Eq, P.Show)

-- ** NotificationSince
newtype NotificationSince = NotificationSince { unNotificationSince :: Text } deriving (P.Eq, P.Show)

-- ** Notifications2
newtype Notifications2 = Notifications2 { unNotifications2 :: Text } deriving (P.Eq, P.Show)

-- ** NotificationsDisplay
newtype NotificationsDisplay = NotificationsDisplay { unNotificationsDisplay :: Text } deriving (P.Eq, P.Show)

-- ** NotificationsEntities
newtype NotificationsEntities = NotificationsEntities { unNotificationsEntities :: Text } deriving (P.Eq, P.Show)

-- ** NotificationsLimit
newtype NotificationsLimit = NotificationsLimit { unNotificationsLimit :: Text } deriving (P.Eq, P.Show)

-- ** OnlyOrgMembers
newtype OnlyOrgMembers = OnlyOrgMembers { unOnlyOrgMembers :: Text } deriving (P.Eq, P.Show)

-- ** Organization
newtype Organization = Organization { unOrganization :: Text } deriving (P.Eq, P.Show)

-- ** OrganizationFields
newtype OrganizationFields = OrganizationFields { unOrganizationFields :: Text } deriving (P.Eq, P.Show)

-- ** OrganizationMemberships
newtype OrganizationMemberships = OrganizationMemberships { unOrganizationMemberships :: Text } deriving (P.Eq, P.Show)

-- ** OrganizationPaidAccount
newtype OrganizationPaidAccount = OrganizationPaidAccount { unOrganizationPaidAccount :: Text } deriving (P.Eq, P.Show)

-- ** Organizations2
newtype Organizations2 = Organizations2 { unOrganizations2 :: Text } deriving (P.Eq, P.Show)

-- ** OrganizationsInvited
newtype OrganizationsInvited = OrganizationsInvited { unOrganizationsInvited :: Text } deriving (P.Eq, P.Show)

-- ** OrganizationsInvitedFields
newtype OrganizationsInvitedFields = OrganizationsInvitedFields { unOrganizationsInvitedFields :: Text } deriving (P.Eq, P.Show)

-- ** OrganizationsLimit
newtype OrganizationsLimit = OrganizationsLimit { unOrganizationsLimit :: Text } deriving (P.Eq, P.Show)

-- ** Page
newtype Page = Page { unPage :: Text } deriving (P.Eq, P.Show)

-- ** PaidAccount
newtype PaidAccount = PaidAccount { unPaidAccount :: Text } deriving (P.Eq, P.Show)

-- ** ParamList
newtype ParamList = ParamList { unParamList :: Text } deriving (P.Eq, P.Show)

-- ** Partial
newtype Partial = Partial { unPartial :: Text } deriving (P.Eq, P.Show)

-- ** PowerUp
newtype PowerUp = PowerUp { unPowerUp :: Text } deriving (P.Eq, P.Show)

-- ** Query
newtype Query = Query { unQuery :: Text } deriving (P.Eq, P.Show)

-- ** ReadFilter
newtype ReadFilter = ReadFilter { unReadFilter :: Text } deriving (P.Eq, P.Show)

-- ** SavedSearches
newtype SavedSearches = SavedSearches { unSavedSearches :: Text } deriving (P.Eq, P.Show)

-- ** Since
newtype Since = Since { unSince :: Text } deriving (P.Eq, P.Show)

-- ** StickerFields
newtype StickerFields = StickerFields { unStickerFields :: Text } deriving (P.Eq, P.Show)

-- ** Stickers
newtype Stickers = Stickers { unStickers :: Text } deriving (P.Eq, P.Show)

-- ** Tags
newtype Tags = Tags { unTags :: Text } deriving (P.Eq, P.Show)

-- ** Token
newtype Token = Token { unToken :: Text } deriving (P.Eq, P.Show)

-- ** Token2
newtype Token2 = Token2 { unToken2 :: Text } deriving (P.Eq, P.Show)

-- ** Tokens
newtype Tokens = Tokens { unTokens :: Text } deriving (P.Eq, P.Show)

-- ** Urls
newtype Urls = Urls { unUrls :: Text } deriving (P.Eq, P.Show)

-- ** Value
newtype Value = Value { unValue :: Text } deriving (P.Eq, P.Show)

-- ** Webhooks2
newtype Webhooks2 = Webhooks2 { unWebhooks2 :: Text } deriving (P.Eq, P.Show)

-- * Models


-- ** Actions
-- | Actions
data Actions = Actions
  { actionsText :: !(Maybe Text) -- ^ "text" - a string with a length from 1 to 16384
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Actions
instance A.FromJSON Actions where
  parseJSON = A.withObject "Actions" $ \o ->
    Actions
      <$> (o .:? "text")

-- | ToJSON Actions
instance A.ToJSON Actions where
  toJSON Actions {..} =
   _omitNulls
      [ "text" .= actionsText
      ]


-- | Construct a value of type 'Actions' (by applying it's required fields, if any)
mkActions
  :: Actions
mkActions =
  Actions
  { actionsText = Nothing
  }

-- ** ActionsComments
-- | ActionsComments
data ActionsComments = ActionsComments
  { actionsCommentsText :: !(Maybe Text) -- ^ "text" - a string with a length from 1 to 16384
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ActionsComments
instance A.FromJSON ActionsComments where
  parseJSON = A.withObject "ActionsComments" $ \o ->
    ActionsComments
      <$> (o .:? "text")

-- | ToJSON ActionsComments
instance A.ToJSON ActionsComments where
  toJSON ActionsComments {..} =
   _omitNulls
      [ "text" .= actionsCommentsText
      ]


-- | Construct a value of type 'ActionsComments' (by applying it's required fields, if any)
mkActionsComments
  :: ActionsComments
mkActionsComments =
  ActionsComments
  { actionsCommentsText = Nothing
  }

-- ** ActionsText
-- | ActionsText
data ActionsText = ActionsText
  { actionsTextValue :: !(Maybe Text) -- ^ "value" - a string with a length from 1 to 16384
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ActionsText
instance A.FromJSON ActionsText where
  parseJSON = A.withObject "ActionsText" $ \o ->
    ActionsText
      <$> (o .:? "value")

-- | ToJSON ActionsText
instance A.ToJSON ActionsText where
  toJSON ActionsText {..} =
   _omitNulls
      [ "value" .= actionsTextValue
      ]


-- | Construct a value of type 'ActionsText' (by applying it's required fields, if any)
mkActionsText
  :: ActionsText
mkActionsText =
  ActionsText
  { actionsTextValue = Nothing
  }

-- ** Boards
-- | Boards
data Boards = Boards
  { boardsClosed :: !(Maybe Text) -- ^ "closed" -  true or false
  , boardsDesc :: !(Maybe Text) -- ^ "desc" - a string with a length from 0 to 16384
  , boardsIdBoardSource :: !(Maybe Text) -- ^ "idBoardSource" - The id of the board to copy into the new board
  , boardsIdOrganization :: !(Maybe Text) -- ^ "idOrganization" - The id or name of the organization to add the board to.
  , boardsKeepFromSource :: !(Maybe Text) -- ^ "keepFromSource" - Components of the source board to copy.
  , boardsLabelNamesblue :: !(Maybe Text) -- ^ "labelNames/blue" - a string with a length from 0 to 16384
  , boardsLabelNamesgreen :: !(Maybe Text) -- ^ "labelNames/green" - a string with a length from 0 to 16384
  , boardsLabelNamesorange :: !(Maybe Text) -- ^ "labelNames/orange" - a string with a length from 0 to 16384
  , boardsLabelNamespurple :: !(Maybe Text) -- ^ "labelNames/purple" - a string with a length from 0 to 16384
  , boardsLabelNamesred :: !(Maybe Text) -- ^ "labelNames/red" - a string with a length from 0 to 16384
  , boardsLabelNamesyellow :: !(Maybe Text) -- ^ "labelNames/yellow" - a string with a length from 0 to 16384
  , boardsName :: !(Maybe Text) -- ^ "name" - a string with a length from 1 to 16384
  , boardsPowerUps :: !(Maybe Text) -- ^ "powerUps" - all or a comma-separated list of: calendar, cardAging, recap or voting
  , boardsPrefsbackground :: !(Maybe Text) -- ^ "prefs/background" - A standard background name, or the id of a custom background
  , boardsPrefscalendarFeedEnabled :: !(Maybe Text) -- ^ "prefs/calendarFeedEnabled" -  true or false
  , boardsPrefscardAging :: !(Maybe Text) -- ^ "prefs/cardAging" - One of: pirate or regular
  , boardsPrefscardCovers :: !(Maybe Text) -- ^ "prefs/cardCovers" -  true or false
  , boardsPrefscomments :: !(Maybe Text) -- ^ "prefs/comments" - One of: disabled, members, observers, org or public
  , boardsPrefsinvitations :: !(Maybe Text) -- ^ "prefs/invitations" - One of: admins or members
  , boardsPrefspermissionLevel :: !(Maybe Text) -- ^ "prefs/permissionLevel" - One of: org, private or public
  , boardsPrefsselfJoin :: !(Maybe Text) -- ^ "prefs/selfJoin" -  true or false
  , boardsPrefsvoting :: !(Maybe Text) -- ^ "prefs/voting" - One of: disabled, members, observers, org or public
  , boardsPrefsBackground :: !(Maybe Text) -- ^ "prefs_background" - a string with a length from 0 to 16384
  , boardsPrefsCardAging :: !(Maybe Text) -- ^ "prefs_cardAging" - One of: pirate or regular
  , boardsPrefsCardCovers :: !(Maybe Text) -- ^ "prefs_cardCovers" -  true or false
  , boardsPrefsComments :: !(Maybe Text) -- ^ "prefs_comments" - One of: disabled, members, observers, org or public
  , boardsPrefsInvitations :: !(Maybe Text) -- ^ "prefs_invitations" - One of: admins or members
  , boardsPrefsPermissionLevel :: !(Maybe Text) -- ^ "prefs_permissionLevel" - One of: org, private or public
  , boardsPrefsSelfJoin :: !(Maybe Text) -- ^ "prefs_selfJoin" -  true or false
  , boardsPrefsVoting :: !(Maybe Text) -- ^ "prefs_voting" - One of: disabled, members, observers, org or public
  , boardsSubscribed :: !(Maybe Text) -- ^ "subscribed" -  true or false
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Boards
instance A.FromJSON Boards where
  parseJSON = A.withObject "Boards" $ \o ->
    Boards
      <$> (o .:? "closed")
      <*> (o .:? "desc")
      <*> (o .:? "idBoardSource")
      <*> (o .:? "idOrganization")
      <*> (o .:? "keepFromSource")
      <*> (o .:? "labelNames/blue")
      <*> (o .:? "labelNames/green")
      <*> (o .:? "labelNames/orange")
      <*> (o .:? "labelNames/purple")
      <*> (o .:? "labelNames/red")
      <*> (o .:? "labelNames/yellow")
      <*> (o .:? "name")
      <*> (o .:? "powerUps")
      <*> (o .:? "prefs/background")
      <*> (o .:? "prefs/calendarFeedEnabled")
      <*> (o .:? "prefs/cardAging")
      <*> (o .:? "prefs/cardCovers")
      <*> (o .:? "prefs/comments")
      <*> (o .:? "prefs/invitations")
      <*> (o .:? "prefs/permissionLevel")
      <*> (o .:? "prefs/selfJoin")
      <*> (o .:? "prefs/voting")
      <*> (o .:? "prefs_background")
      <*> (o .:? "prefs_cardAging")
      <*> (o .:? "prefs_cardCovers")
      <*> (o .:? "prefs_comments")
      <*> (o .:? "prefs_invitations")
      <*> (o .:? "prefs_permissionLevel")
      <*> (o .:? "prefs_selfJoin")
      <*> (o .:? "prefs_voting")
      <*> (o .:? "subscribed")

-- | ToJSON Boards
instance A.ToJSON Boards where
  toJSON Boards {..} =
   _omitNulls
      [ "closed" .= boardsClosed
      , "desc" .= boardsDesc
      , "idBoardSource" .= boardsIdBoardSource
      , "idOrganization" .= boardsIdOrganization
      , "keepFromSource" .= boardsKeepFromSource
      , "labelNames/blue" .= boardsLabelNamesblue
      , "labelNames/green" .= boardsLabelNamesgreen
      , "labelNames/orange" .= boardsLabelNamesorange
      , "labelNames/purple" .= boardsLabelNamespurple
      , "labelNames/red" .= boardsLabelNamesred
      , "labelNames/yellow" .= boardsLabelNamesyellow
      , "name" .= boardsName
      , "powerUps" .= boardsPowerUps
      , "prefs/background" .= boardsPrefsbackground
      , "prefs/calendarFeedEnabled" .= boardsPrefscalendarFeedEnabled
      , "prefs/cardAging" .= boardsPrefscardAging
      , "prefs/cardCovers" .= boardsPrefscardCovers
      , "prefs/comments" .= boardsPrefscomments
      , "prefs/invitations" .= boardsPrefsinvitations
      , "prefs/permissionLevel" .= boardsPrefspermissionLevel
      , "prefs/selfJoin" .= boardsPrefsselfJoin
      , "prefs/voting" .= boardsPrefsvoting
      , "prefs_background" .= boardsPrefsBackground
      , "prefs_cardAging" .= boardsPrefsCardAging
      , "prefs_cardCovers" .= boardsPrefsCardCovers
      , "prefs_comments" .= boardsPrefsComments
      , "prefs_invitations" .= boardsPrefsInvitations
      , "prefs_permissionLevel" .= boardsPrefsPermissionLevel
      , "prefs_selfJoin" .= boardsPrefsSelfJoin
      , "prefs_voting" .= boardsPrefsVoting
      , "subscribed" .= boardsSubscribed
      ]


-- | Construct a value of type 'Boards' (by applying it's required fields, if any)
mkBoards
  :: Boards
mkBoards =
  Boards
  { boardsClosed = Nothing
  , boardsDesc = Nothing
  , boardsIdBoardSource = Nothing
  , boardsIdOrganization = Nothing
  , boardsKeepFromSource = Nothing
  , boardsLabelNamesblue = Nothing
  , boardsLabelNamesgreen = Nothing
  , boardsLabelNamesorange = Nothing
  , boardsLabelNamespurple = Nothing
  , boardsLabelNamesred = Nothing
  , boardsLabelNamesyellow = Nothing
  , boardsName = Nothing
  , boardsPowerUps = Nothing
  , boardsPrefsbackground = Nothing
  , boardsPrefscalendarFeedEnabled = Nothing
  , boardsPrefscardAging = Nothing
  , boardsPrefscardCovers = Nothing
  , boardsPrefscomments = Nothing
  , boardsPrefsinvitations = Nothing
  , boardsPrefspermissionLevel = Nothing
  , boardsPrefsselfJoin = Nothing
  , boardsPrefsvoting = Nothing
  , boardsPrefsBackground = Nothing
  , boardsPrefsCardAging = Nothing
  , boardsPrefsCardCovers = Nothing
  , boardsPrefsComments = Nothing
  , boardsPrefsInvitations = Nothing
  , boardsPrefsPermissionLevel = Nothing
  , boardsPrefsSelfJoin = Nothing
  , boardsPrefsVoting = Nothing
  , boardsSubscribed = Nothing
  }

-- ** BoardsChecklists
-- | BoardsChecklists
data BoardsChecklists = BoardsChecklists
  { boardsChecklistsName :: !(Maybe Text) -- ^ "name" - a string with a length from 1 to 16384
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BoardsChecklists
instance A.FromJSON BoardsChecklists where
  parseJSON = A.withObject "BoardsChecklists" $ \o ->
    BoardsChecklists
      <$> (o .:? "name")

-- | ToJSON BoardsChecklists
instance A.ToJSON BoardsChecklists where
  toJSON BoardsChecklists {..} =
   _omitNulls
      [ "name" .= boardsChecklistsName
      ]


-- | Construct a value of type 'BoardsChecklists' (by applying it's required fields, if any)
mkBoardsChecklists
  :: BoardsChecklists
mkBoardsChecklists =
  BoardsChecklists
  { boardsChecklistsName = Nothing
  }

-- ** BoardsClosed
-- | BoardsClosed
data BoardsClosed = BoardsClosed
  { boardsClosedValue :: !(Maybe Text) -- ^ "value" -  true or false
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BoardsClosed
instance A.FromJSON BoardsClosed where
  parseJSON = A.withObject "BoardsClosed" $ \o ->
    BoardsClosed
      <$> (o .:? "value")

-- | ToJSON BoardsClosed
instance A.ToJSON BoardsClosed where
  toJSON BoardsClosed {..} =
   _omitNulls
      [ "value" .= boardsClosedValue
      ]


-- | Construct a value of type 'BoardsClosed' (by applying it's required fields, if any)
mkBoardsClosed
  :: BoardsClosed
mkBoardsClosed =
  BoardsClosed
  { boardsClosedValue = Nothing
  }

-- ** BoardsDesc
-- | BoardsDesc
data BoardsDesc = BoardsDesc
  { boardsDescValue :: !(Maybe Text) -- ^ "value" - a string with a length from 0 to 16384
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BoardsDesc
instance A.FromJSON BoardsDesc where
  parseJSON = A.withObject "BoardsDesc" $ \o ->
    BoardsDesc
      <$> (o .:? "value")

-- | ToJSON BoardsDesc
instance A.ToJSON BoardsDesc where
  toJSON BoardsDesc {..} =
   _omitNulls
      [ "value" .= boardsDescValue
      ]


-- | Construct a value of type 'BoardsDesc' (by applying it's required fields, if any)
mkBoardsDesc
  :: BoardsDesc
mkBoardsDesc =
  BoardsDesc
  { boardsDescValue = Nothing
  }

-- ** BoardsIdOrganization
-- | BoardsIdOrganization
data BoardsIdOrganization = BoardsIdOrganization
  { boardsIdOrganizationValue :: !(Maybe Text) -- ^ "value" - a string with a length from 0 to 16384
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BoardsIdOrganization
instance A.FromJSON BoardsIdOrganization where
  parseJSON = A.withObject "BoardsIdOrganization" $ \o ->
    BoardsIdOrganization
      <$> (o .:? "value")

-- | ToJSON BoardsIdOrganization
instance A.ToJSON BoardsIdOrganization where
  toJSON BoardsIdOrganization {..} =
   _omitNulls
      [ "value" .= boardsIdOrganizationValue
      ]


-- | Construct a value of type 'BoardsIdOrganization' (by applying it's required fields, if any)
mkBoardsIdOrganization
  :: BoardsIdOrganization
mkBoardsIdOrganization =
  BoardsIdOrganization
  { boardsIdOrganizationValue = Nothing
  }

-- ** BoardsLabels
-- | BoardsLabels
data BoardsLabels = BoardsLabels
  { boardsLabelsColor :: !(Maybe Text) -- ^ "color" - A valid label color or null
  , boardsLabelsName :: !(Maybe Text) -- ^ "name" - a string with a length from 0 to 16384
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BoardsLabels
instance A.FromJSON BoardsLabels where
  parseJSON = A.withObject "BoardsLabels" $ \o ->
    BoardsLabels
      <$> (o .:? "color")
      <*> (o .:? "name")

-- | ToJSON BoardsLabels
instance A.ToJSON BoardsLabels where
  toJSON BoardsLabels {..} =
   _omitNulls
      [ "color" .= boardsLabelsColor
      , "name" .= boardsLabelsName
      ]


-- | Construct a value of type 'BoardsLabels' (by applying it's required fields, if any)
mkBoardsLabels
  :: BoardsLabels
mkBoardsLabels =
  BoardsLabels
  { boardsLabelsColor = Nothing
  , boardsLabelsName = Nothing
  }

-- ** BoardsLists
-- | BoardsLists
data BoardsLists = BoardsLists
  { boardsListsName :: !(Maybe Text) -- ^ "name" - a string with a length from 1 to 16384
  , boardsListsPos :: !(Maybe Text) -- ^ "pos" - A position. top , bottom , or a positive number.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BoardsLists
instance A.FromJSON BoardsLists where
  parseJSON = A.withObject "BoardsLists" $ \o ->
    BoardsLists
      <$> (o .:? "name")
      <*> (o .:? "pos")

-- | ToJSON BoardsLists
instance A.ToJSON BoardsLists where
  toJSON BoardsLists {..} =
   _omitNulls
      [ "name" .= boardsListsName
      , "pos" .= boardsListsPos
      ]


-- | Construct a value of type 'BoardsLists' (by applying it's required fields, if any)
mkBoardsLists
  :: BoardsLists
mkBoardsLists =
  BoardsLists
  { boardsListsName = Nothing
  , boardsListsPos = Nothing
  }

-- ** BoardsMembers
-- | BoardsMembers
data BoardsMembers = BoardsMembers
  { boardsMembersEmail :: !(Maybe Text) -- ^ "email" - An email address
  , boardsMembersFullName :: !(Maybe Text) -- ^ "fullName" - A string with a length of at least 1.  Cannot begin or end with a space.
  , boardsMembersType :: !(Maybe Text) -- ^ "type" - One of: admin, normal or observer
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BoardsMembers
instance A.FromJSON BoardsMembers where
  parseJSON = A.withObject "BoardsMembers" $ \o ->
    BoardsMembers
      <$> (o .:? "email")
      <*> (o .:? "fullName")
      <*> (o .:? "type")

-- | ToJSON BoardsMembers
instance A.ToJSON BoardsMembers where
  toJSON BoardsMembers {..} =
   _omitNulls
      [ "email" .= boardsMembersEmail
      , "fullName" .= boardsMembersFullName
      , "type" .= boardsMembersType
      ]


-- | Construct a value of type 'BoardsMembers' (by applying it's required fields, if any)
mkBoardsMembers
  :: BoardsMembers
mkBoardsMembers =
  BoardsMembers
  { boardsMembersEmail = Nothing
  , boardsMembersFullName = Nothing
  , boardsMembersType = Nothing
  }

-- ** BoardsMemberships
-- | BoardsMemberships
data BoardsMemberships = BoardsMemberships
  { boardsMembershipsMemberFields :: !(Maybe Text) -- ^ "member_fields" - all or a comma-separated list of: avatarHash, bio, bioData, confirmed, fullName, idPremOrgsAdmin, initials, memberType, products, status, url or username
  , boardsMembershipsType :: !(Maybe Text) -- ^ "type" - One of: admin, normal or observer
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BoardsMemberships
instance A.FromJSON BoardsMemberships where
  parseJSON = A.withObject "BoardsMemberships" $ \o ->
    BoardsMemberships
      <$> (o .:? "member_fields")
      <*> (o .:? "type")

-- | ToJSON BoardsMemberships
instance A.ToJSON BoardsMemberships where
  toJSON BoardsMemberships {..} =
   _omitNulls
      [ "member_fields" .= boardsMembershipsMemberFields
      , "type" .= boardsMembershipsType
      ]


-- | Construct a value of type 'BoardsMemberships' (by applying it's required fields, if any)
mkBoardsMemberships
  :: BoardsMemberships
mkBoardsMemberships =
  BoardsMemberships
  { boardsMembershipsMemberFields = Nothing
  , boardsMembershipsType = Nothing
  }

-- ** BoardsName
-- | BoardsName
data BoardsName = BoardsName
  { boardsNameValue :: !(Maybe Text) -- ^ "value" - a string with a length from 1 to 16384
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BoardsName
instance A.FromJSON BoardsName where
  parseJSON = A.withObject "BoardsName" $ \o ->
    BoardsName
      <$> (o .:? "value")

-- | ToJSON BoardsName
instance A.ToJSON BoardsName where
  toJSON BoardsName {..} =
   _omitNulls
      [ "value" .= boardsNameValue
      ]


-- | Construct a value of type 'BoardsName' (by applying it's required fields, if any)
mkBoardsName
  :: BoardsName
mkBoardsName =
  BoardsName
  { boardsNameValue = Nothing
  }

-- ** BoardsPowerUps
-- | BoardsPowerUps
data BoardsPowerUps = BoardsPowerUps
  { boardsPowerUpsValue :: !(Maybe Text) -- ^ "value" - One of: calendar, cardAging, recap or voting
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BoardsPowerUps
instance A.FromJSON BoardsPowerUps where
  parseJSON = A.withObject "BoardsPowerUps" $ \o ->
    BoardsPowerUps
      <$> (o .:? "value")

-- | ToJSON BoardsPowerUps
instance A.ToJSON BoardsPowerUps where
  toJSON BoardsPowerUps {..} =
   _omitNulls
      [ "value" .= boardsPowerUpsValue
      ]


-- | Construct a value of type 'BoardsPowerUps' (by applying it's required fields, if any)
mkBoardsPowerUps
  :: BoardsPowerUps
mkBoardsPowerUps =
  BoardsPowerUps
  { boardsPowerUpsValue = Nothing
  }

-- ** BoardsSubscribed
-- | BoardsSubscribed
data BoardsSubscribed = BoardsSubscribed
  { boardsSubscribedValue :: !(Maybe Text) -- ^ "value" -  true or false
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BoardsSubscribed
instance A.FromJSON BoardsSubscribed where
  parseJSON = A.withObject "BoardsSubscribed" $ \o ->
    BoardsSubscribed
      <$> (o .:? "value")

-- | ToJSON BoardsSubscribed
instance A.ToJSON BoardsSubscribed where
  toJSON BoardsSubscribed {..} =
   _omitNulls
      [ "value" .= boardsSubscribedValue
      ]


-- | Construct a value of type 'BoardsSubscribed' (by applying it's required fields, if any)
mkBoardsSubscribed
  :: BoardsSubscribed
mkBoardsSubscribed =
  BoardsSubscribed
  { boardsSubscribedValue = Nothing
  }

-- ** Cards
-- | Cards
data Cards = Cards
  { cardsClosed :: !(Maybe Text) -- ^ "closed" -  true or false
  , cardsDesc :: !(Maybe Text) -- ^ "desc" - a string with a length from 0 to 16384
  , cardsDue :: !(Maybe Text) -- ^ "due" - A date, or null
  , cardsFileSource :: !(Maybe Text) -- ^ "fileSource" - A file
  , cardsIdAttachmentCover :: !(Maybe Text) -- ^ "idAttachmentCover" - Id of the image attachment of this card to use as its cover, or null for no cover
  , cardsIdBoard :: !(Maybe Text) -- ^ "idBoard" - id of the board the card should be moved to
  , cardsIdCardSource :: !(Maybe Text) -- ^ "idCardSource" - The id of the card to copy into a new card.
  , cardsIdLabels :: !(Maybe Text) -- ^ "idLabels" - A comma-separated list of objectIds, 24-character hex strings
  , cardsIdList :: !(Maybe Text) -- ^ "idList" - id of the list that the card should be added to
  , cardsIdMembers :: !(Maybe Text) -- ^ "idMembers" - A comma-separated list of objectIds, 24-character hex strings
  , cardsKeepFromSource :: !(Maybe Text) -- ^ "keepFromSource" - Properties of the card to copy over from the source.
  , cardsLabels :: !(Maybe Text) -- ^ "labels" - all or a comma-separated list of: blue, green, orange, purple, red or yellow
  , cardsName :: !(Maybe Text) -- ^ "name" - The name of the new card.  It isn&amp;#39;t required if the name is being copied from provided by a URL, file or card that is being copied.
  , cardsPos :: !(Maybe Text) -- ^ "pos" - A position. top , bottom , or a positive number.
  , cardsSubscribed :: !(Maybe Text) -- ^ "subscribed" -  true or false
  , cardsUrlSource :: !(Maybe Text) -- ^ "urlSource" - A URL starting with http:// or https:// or null
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Cards
instance A.FromJSON Cards where
  parseJSON = A.withObject "Cards" $ \o ->
    Cards
      <$> (o .:? "closed")
      <*> (o .:? "desc")
      <*> (o .:? "due")
      <*> (o .:? "fileSource")
      <*> (o .:? "idAttachmentCover")
      <*> (o .:? "idBoard")
      <*> (o .:? "idCardSource")
      <*> (o .:? "idLabels")
      <*> (o .:? "idList")
      <*> (o .:? "idMembers")
      <*> (o .:? "keepFromSource")
      <*> (o .:? "labels")
      <*> (o .:? "name")
      <*> (o .:? "pos")
      <*> (o .:? "subscribed")
      <*> (o .:? "urlSource")

-- | ToJSON Cards
instance A.ToJSON Cards where
  toJSON Cards {..} =
   _omitNulls
      [ "closed" .= cardsClosed
      , "desc" .= cardsDesc
      , "due" .= cardsDue
      , "fileSource" .= cardsFileSource
      , "idAttachmentCover" .= cardsIdAttachmentCover
      , "idBoard" .= cardsIdBoard
      , "idCardSource" .= cardsIdCardSource
      , "idLabels" .= cardsIdLabels
      , "idList" .= cardsIdList
      , "idMembers" .= cardsIdMembers
      , "keepFromSource" .= cardsKeepFromSource
      , "labels" .= cardsLabels
      , "name" .= cardsName
      , "pos" .= cardsPos
      , "subscribed" .= cardsSubscribed
      , "urlSource" .= cardsUrlSource
      ]


-- | Construct a value of type 'Cards' (by applying it's required fields, if any)
mkCards
  :: Cards
mkCards =
  Cards
  { cardsClosed = Nothing
  , cardsDesc = Nothing
  , cardsDue = Nothing
  , cardsFileSource = Nothing
  , cardsIdAttachmentCover = Nothing
  , cardsIdBoard = Nothing
  , cardsIdCardSource = Nothing
  , cardsIdLabels = Nothing
  , cardsIdList = Nothing
  , cardsIdMembers = Nothing
  , cardsKeepFromSource = Nothing
  , cardsLabels = Nothing
  , cardsName = Nothing
  , cardsPos = Nothing
  , cardsSubscribed = Nothing
  , cardsUrlSource = Nothing
  }

-- ** CardsActionsComments
-- | CardsActionsComments
data CardsActionsComments = CardsActionsComments
  { cardsActionsCommentsText :: !(Maybe Text) -- ^ "text" - a string with a length from 1 to 16384
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CardsActionsComments
instance A.FromJSON CardsActionsComments where
  parseJSON = A.withObject "CardsActionsComments" $ \o ->
    CardsActionsComments
      <$> (o .:? "text")

-- | ToJSON CardsActionsComments
instance A.ToJSON CardsActionsComments where
  toJSON CardsActionsComments {..} =
   _omitNulls
      [ "text" .= cardsActionsCommentsText
      ]


-- | Construct a value of type 'CardsActionsComments' (by applying it's required fields, if any)
mkCardsActionsComments
  :: CardsActionsComments
mkCardsActionsComments =
  CardsActionsComments
  { cardsActionsCommentsText = Nothing
  }

-- ** CardsAttachments
-- | CardsAttachments
data CardsAttachments = CardsAttachments
  { cardsAttachmentsFile :: !(Maybe Text) -- ^ "file" - A file
  , cardsAttachmentsMimeType :: !(Maybe Text) -- ^ "mimeType" - a string with a length from 0 to 256
  , cardsAttachmentsName :: !(Maybe Text) -- ^ "name" - a string with a length from 0 to 256
  , cardsAttachmentsUrl :: !(Maybe Text) -- ^ "url" - A URL starting with http:// or https:// or null
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CardsAttachments
instance A.FromJSON CardsAttachments where
  parseJSON = A.withObject "CardsAttachments" $ \o ->
    CardsAttachments
      <$> (o .:? "file")
      <*> (o .:? "mimeType")
      <*> (o .:? "name")
      <*> (o .:? "url")

-- | ToJSON CardsAttachments
instance A.ToJSON CardsAttachments where
  toJSON CardsAttachments {..} =
   _omitNulls
      [ "file" .= cardsAttachmentsFile
      , "mimeType" .= cardsAttachmentsMimeType
      , "name" .= cardsAttachmentsName
      , "url" .= cardsAttachmentsUrl
      ]


-- | Construct a value of type 'CardsAttachments' (by applying it's required fields, if any)
mkCardsAttachments
  :: CardsAttachments
mkCardsAttachments =
  CardsAttachments
  { cardsAttachmentsFile = Nothing
  , cardsAttachmentsMimeType = Nothing
  , cardsAttachmentsName = Nothing
  , cardsAttachmentsUrl = Nothing
  }

-- ** CardsChecklistCheckItem
-- | CardsChecklistCheckItem
data CardsChecklistCheckItem = CardsChecklistCheckItem
  { cardsChecklistCheckItemName :: !(Maybe Text) -- ^ "name" - a string with a length from 1 to 16384
  , cardsChecklistCheckItemPos :: !(Maybe Text) -- ^ "pos" - A position. top , bottom , or a positive number.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CardsChecklistCheckItem
instance A.FromJSON CardsChecklistCheckItem where
  parseJSON = A.withObject "CardsChecklistCheckItem" $ \o ->
    CardsChecklistCheckItem
      <$> (o .:? "name")
      <*> (o .:? "pos")

-- | ToJSON CardsChecklistCheckItem
instance A.ToJSON CardsChecklistCheckItem where
  toJSON CardsChecklistCheckItem {..} =
   _omitNulls
      [ "name" .= cardsChecklistCheckItemName
      , "pos" .= cardsChecklistCheckItemPos
      ]


-- | Construct a value of type 'CardsChecklistCheckItem' (by applying it's required fields, if any)
mkCardsChecklistCheckItem
  :: CardsChecklistCheckItem
mkCardsChecklistCheckItem =
  CardsChecklistCheckItem
  { cardsChecklistCheckItemName = Nothing
  , cardsChecklistCheckItemPos = Nothing
  }

-- ** CardsChecklistCheckItemName
-- | CardsChecklistCheckItemName
data CardsChecklistCheckItemName = CardsChecklistCheckItemName
  { cardsChecklistCheckItemNameValue :: !(Maybe Text) -- ^ "value" - a string with a length from 1 to 16384
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CardsChecklistCheckItemName
instance A.FromJSON CardsChecklistCheckItemName where
  parseJSON = A.withObject "CardsChecklistCheckItemName" $ \o ->
    CardsChecklistCheckItemName
      <$> (o .:? "value")

-- | ToJSON CardsChecklistCheckItemName
instance A.ToJSON CardsChecklistCheckItemName where
  toJSON CardsChecklistCheckItemName {..} =
   _omitNulls
      [ "value" .= cardsChecklistCheckItemNameValue
      ]


-- | Construct a value of type 'CardsChecklistCheckItemName' (by applying it's required fields, if any)
mkCardsChecklistCheckItemName
  :: CardsChecklistCheckItemName
mkCardsChecklistCheckItemName =
  CardsChecklistCheckItemName
  { cardsChecklistCheckItemNameValue = Nothing
  }

-- ** CardsChecklistCheckItemPos
-- | CardsChecklistCheckItemPos
data CardsChecklistCheckItemPos = CardsChecklistCheckItemPos
  { cardsChecklistCheckItemPosValue :: !(Maybe Text) -- ^ "value" - A position. top , bottom , or a positive number.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CardsChecklistCheckItemPos
instance A.FromJSON CardsChecklistCheckItemPos where
  parseJSON = A.withObject "CardsChecklistCheckItemPos" $ \o ->
    CardsChecklistCheckItemPos
      <$> (o .:? "value")

-- | ToJSON CardsChecklistCheckItemPos
instance A.ToJSON CardsChecklistCheckItemPos where
  toJSON CardsChecklistCheckItemPos {..} =
   _omitNulls
      [ "value" .= cardsChecklistCheckItemPosValue
      ]


-- | Construct a value of type 'CardsChecklistCheckItemPos' (by applying it's required fields, if any)
mkCardsChecklistCheckItemPos
  :: CardsChecklistCheckItemPos
mkCardsChecklistCheckItemPos =
  CardsChecklistCheckItemPos
  { cardsChecklistCheckItemPosValue = Nothing
  }

-- ** CardsChecklistCheckItemState
-- | CardsChecklistCheckItemState
data CardsChecklistCheckItemState = CardsChecklistCheckItemState
  { cardsChecklistCheckItemStateValue :: !(Maybe Text) -- ^ "value" - One of: complete, false, incomplete or true
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CardsChecklistCheckItemState
instance A.FromJSON CardsChecklistCheckItemState where
  parseJSON = A.withObject "CardsChecklistCheckItemState" $ \o ->
    CardsChecklistCheckItemState
      <$> (o .:? "value")

-- | ToJSON CardsChecklistCheckItemState
instance A.ToJSON CardsChecklistCheckItemState where
  toJSON CardsChecklistCheckItemState {..} =
   _omitNulls
      [ "value" .= cardsChecklistCheckItemStateValue
      ]


-- | Construct a value of type 'CardsChecklistCheckItemState' (by applying it's required fields, if any)
mkCardsChecklistCheckItemState
  :: CardsChecklistCheckItemState
mkCardsChecklistCheckItemState =
  CardsChecklistCheckItemState
  { cardsChecklistCheckItemStateValue = Nothing
  }

-- ** CardsChecklistIdChecklistCurrentCheckItem
-- | CardsChecklistIdChecklistCurrentCheckItem
data CardsChecklistIdChecklistCurrentCheckItem = CardsChecklistIdChecklistCurrentCheckItem
  { cardsChecklistIdChecklistCurrentCheckItemIdChecklist :: !(Maybe Text) -- ^ "idChecklist" - An id, or null
  , cardsChecklistIdChecklistCurrentCheckItemName :: !(Maybe Text) -- ^ "name" - a string with a length from 1 to 16384
  , cardsChecklistIdChecklistCurrentCheckItemPos :: !(Maybe Text) -- ^ "pos" - A position. top , bottom , or a positive number.
  , cardsChecklistIdChecklistCurrentCheckItemState :: !(Maybe Text) -- ^ "state" - One of: complete, false, incomplete or true
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CardsChecklistIdChecklistCurrentCheckItem
instance A.FromJSON CardsChecklistIdChecklistCurrentCheckItem where
  parseJSON = A.withObject "CardsChecklistIdChecklistCurrentCheckItem" $ \o ->
    CardsChecklistIdChecklistCurrentCheckItem
      <$> (o .:? "idChecklist")
      <*> (o .:? "name")
      <*> (o .:? "pos")
      <*> (o .:? "state")

-- | ToJSON CardsChecklistIdChecklistCurrentCheckItem
instance A.ToJSON CardsChecklistIdChecklistCurrentCheckItem where
  toJSON CardsChecklistIdChecklistCurrentCheckItem {..} =
   _omitNulls
      [ "idChecklist" .= cardsChecklistIdChecklistCurrentCheckItemIdChecklist
      , "name" .= cardsChecklistIdChecklistCurrentCheckItemName
      , "pos" .= cardsChecklistIdChecklistCurrentCheckItemPos
      , "state" .= cardsChecklistIdChecklistCurrentCheckItemState
      ]


-- | Construct a value of type 'CardsChecklistIdChecklistCurrentCheckItem' (by applying it's required fields, if any)
mkCardsChecklistIdChecklistCurrentCheckItem
  :: CardsChecklistIdChecklistCurrentCheckItem
mkCardsChecklistIdChecklistCurrentCheckItem =
  CardsChecklistIdChecklistCurrentCheckItem
  { cardsChecklistIdChecklistCurrentCheckItemIdChecklist = Nothing
  , cardsChecklistIdChecklistCurrentCheckItemName = Nothing
  , cardsChecklistIdChecklistCurrentCheckItemPos = Nothing
  , cardsChecklistIdChecklistCurrentCheckItemState = Nothing
  }

-- ** CardsChecklists
-- | CardsChecklists
data CardsChecklists = CardsChecklists
  { cardsChecklistsIdChecklistSource :: !(Maybe Text) -- ^ "idChecklistSource" - The id of the source checklist to copy into a new checklist.
  , cardsChecklistsName :: !(Maybe Text) -- ^ "name" - a string with a length from 0 to 16384
  , cardsChecklistsValue :: !(Maybe Text) -- ^ "value" - The id of the checklist to add to the card, or null to create a new one.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CardsChecklists
instance A.FromJSON CardsChecklists where
  parseJSON = A.withObject "CardsChecklists" $ \o ->
    CardsChecklists
      <$> (o .:? "idChecklistSource")
      <*> (o .:? "name")
      <*> (o .:? "value")

-- | ToJSON CardsChecklists
instance A.ToJSON CardsChecklists where
  toJSON CardsChecklists {..} =
   _omitNulls
      [ "idChecklistSource" .= cardsChecklistsIdChecklistSource
      , "name" .= cardsChecklistsName
      , "value" .= cardsChecklistsValue
      ]


-- | Construct a value of type 'CardsChecklists' (by applying it's required fields, if any)
mkCardsChecklists
  :: CardsChecklists
mkCardsChecklists =
  CardsChecklists
  { cardsChecklistsIdChecklistSource = Nothing
  , cardsChecklistsName = Nothing
  , cardsChecklistsValue = Nothing
  }

-- ** CardsClosed
-- | CardsClosed
data CardsClosed = CardsClosed
  { cardsClosedValue :: !(Maybe Text) -- ^ "value" -  true or false
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CardsClosed
instance A.FromJSON CardsClosed where
  parseJSON = A.withObject "CardsClosed" $ \o ->
    CardsClosed
      <$> (o .:? "value")

-- | ToJSON CardsClosed
instance A.ToJSON CardsClosed where
  toJSON CardsClosed {..} =
   _omitNulls
      [ "value" .= cardsClosedValue
      ]


-- | Construct a value of type 'CardsClosed' (by applying it's required fields, if any)
mkCardsClosed
  :: CardsClosed
mkCardsClosed =
  CardsClosed
  { cardsClosedValue = Nothing
  }

-- ** CardsDesc
-- | CardsDesc
data CardsDesc = CardsDesc
  { cardsDescValue :: !(Maybe Text) -- ^ "value" - a string with a length from 0 to 16384
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CardsDesc
instance A.FromJSON CardsDesc where
  parseJSON = A.withObject "CardsDesc" $ \o ->
    CardsDesc
      <$> (o .:? "value")

-- | ToJSON CardsDesc
instance A.ToJSON CardsDesc where
  toJSON CardsDesc {..} =
   _omitNulls
      [ "value" .= cardsDescValue
      ]


-- | Construct a value of type 'CardsDesc' (by applying it's required fields, if any)
mkCardsDesc
  :: CardsDesc
mkCardsDesc =
  CardsDesc
  { cardsDescValue = Nothing
  }

-- ** CardsDue
-- | CardsDue
data CardsDue = CardsDue
  { cardsDueValue :: !(Maybe Text) -- ^ "value" - A date, or null
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CardsDue
instance A.FromJSON CardsDue where
  parseJSON = A.withObject "CardsDue" $ \o ->
    CardsDue
      <$> (o .:? "value")

-- | ToJSON CardsDue
instance A.ToJSON CardsDue where
  toJSON CardsDue {..} =
   _omitNulls
      [ "value" .= cardsDueValue
      ]


-- | Construct a value of type 'CardsDue' (by applying it's required fields, if any)
mkCardsDue
  :: CardsDue
mkCardsDue =
  CardsDue
  { cardsDueValue = Nothing
  }

-- ** CardsIdAttachmentCover
-- | CardsIdAttachmentCover
data CardsIdAttachmentCover = CardsIdAttachmentCover
  { cardsIdAttachmentCoverValue :: !(Maybe Text) -- ^ "value" - Id of the image attachment of this card to use as its cover, or null for no cover
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CardsIdAttachmentCover
instance A.FromJSON CardsIdAttachmentCover where
  parseJSON = A.withObject "CardsIdAttachmentCover" $ \o ->
    CardsIdAttachmentCover
      <$> (o .:? "value")

-- | ToJSON CardsIdAttachmentCover
instance A.ToJSON CardsIdAttachmentCover where
  toJSON CardsIdAttachmentCover {..} =
   _omitNulls
      [ "value" .= cardsIdAttachmentCoverValue
      ]


-- | Construct a value of type 'CardsIdAttachmentCover' (by applying it's required fields, if any)
mkCardsIdAttachmentCover
  :: CardsIdAttachmentCover
mkCardsIdAttachmentCover =
  CardsIdAttachmentCover
  { cardsIdAttachmentCoverValue = Nothing
  }

-- ** CardsIdBoard
-- | CardsIdBoard
data CardsIdBoard = CardsIdBoard
  { cardsIdBoardIdList :: !(Maybe Text) -- ^ "idList" - id of the list that the card should be moved to on the new board
  , cardsIdBoardValue :: !(Maybe Text) -- ^ "value" - id of the board the card should be moved to
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CardsIdBoard
instance A.FromJSON CardsIdBoard where
  parseJSON = A.withObject "CardsIdBoard" $ \o ->
    CardsIdBoard
      <$> (o .:? "idList")
      <*> (o .:? "value")

-- | ToJSON CardsIdBoard
instance A.ToJSON CardsIdBoard where
  toJSON CardsIdBoard {..} =
   _omitNulls
      [ "idList" .= cardsIdBoardIdList
      , "value" .= cardsIdBoardValue
      ]


-- | Construct a value of type 'CardsIdBoard' (by applying it's required fields, if any)
mkCardsIdBoard
  :: CardsIdBoard
mkCardsIdBoard =
  CardsIdBoard
  { cardsIdBoardIdList = Nothing
  , cardsIdBoardValue = Nothing
  }

-- ** CardsIdLabels
-- | CardsIdLabels
data CardsIdLabels = CardsIdLabels
  { cardsIdLabelsValue :: !(Maybe Text) -- ^ "value" - The id of the label to add
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CardsIdLabels
instance A.FromJSON CardsIdLabels where
  parseJSON = A.withObject "CardsIdLabels" $ \o ->
    CardsIdLabels
      <$> (o .:? "value")

-- | ToJSON CardsIdLabels
instance A.ToJSON CardsIdLabels where
  toJSON CardsIdLabels {..} =
   _omitNulls
      [ "value" .= cardsIdLabelsValue
      ]


-- | Construct a value of type 'CardsIdLabels' (by applying it's required fields, if any)
mkCardsIdLabels
  :: CardsIdLabels
mkCardsIdLabels =
  CardsIdLabels
  { cardsIdLabelsValue = Nothing
  }

-- ** CardsIdList
-- | CardsIdList
data CardsIdList = CardsIdList
  { cardsIdListValue :: !(Maybe Text) -- ^ "value" - id of the list the card should be moved to
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CardsIdList
instance A.FromJSON CardsIdList where
  parseJSON = A.withObject "CardsIdList" $ \o ->
    CardsIdList
      <$> (o .:? "value")

-- | ToJSON CardsIdList
instance A.ToJSON CardsIdList where
  toJSON CardsIdList {..} =
   _omitNulls
      [ "value" .= cardsIdListValue
      ]


-- | Construct a value of type 'CardsIdList' (by applying it's required fields, if any)
mkCardsIdList
  :: CardsIdList
mkCardsIdList =
  CardsIdList
  { cardsIdListValue = Nothing
  }

-- ** CardsIdMembers
-- | CardsIdMembers
data CardsIdMembers = CardsIdMembers
  { cardsIdMembersValue :: !(Maybe Text) -- ^ "value" - The id of the member to add to the card
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CardsIdMembers
instance A.FromJSON CardsIdMembers where
  parseJSON = A.withObject "CardsIdMembers" $ \o ->
    CardsIdMembers
      <$> (o .:? "value")

-- | ToJSON CardsIdMembers
instance A.ToJSON CardsIdMembers where
  toJSON CardsIdMembers {..} =
   _omitNulls
      [ "value" .= cardsIdMembersValue
      ]


-- | Construct a value of type 'CardsIdMembers' (by applying it's required fields, if any)
mkCardsIdMembers
  :: CardsIdMembers
mkCardsIdMembers =
  CardsIdMembers
  { cardsIdMembersValue = Nothing
  }

-- ** CardsLabels
-- | CardsLabels
data CardsLabels = CardsLabels
  { cardsLabelsColor :: !(Maybe Text) -- ^ "color" - A valid label color or null
  , cardsLabelsName :: !(Maybe Text) -- ^ "name" - a string with a length from 0 to 16384
  , cardsLabelsValue :: !(Maybe Text) -- ^ "value" - all or a comma-separated list of: blue, green, orange, purple, red or yellow
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CardsLabels
instance A.FromJSON CardsLabels where
  parseJSON = A.withObject "CardsLabels" $ \o ->
    CardsLabels
      <$> (o .:? "color")
      <*> (o .:? "name")
      <*> (o .:? "value")

-- | ToJSON CardsLabels
instance A.ToJSON CardsLabels where
  toJSON CardsLabels {..} =
   _omitNulls
      [ "color" .= cardsLabelsColor
      , "name" .= cardsLabelsName
      , "value" .= cardsLabelsValue
      ]


-- | Construct a value of type 'CardsLabels' (by applying it's required fields, if any)
mkCardsLabels
  :: CardsLabels
mkCardsLabels =
  CardsLabels
  { cardsLabelsColor = Nothing
  , cardsLabelsName = Nothing
  , cardsLabelsValue = Nothing
  }

-- ** CardsMembersVoted
-- | CardsMembersVoted
data CardsMembersVoted = CardsMembersVoted
  { cardsMembersVotedValue :: !(Maybe Text) -- ^ "value" - The id of the member to vote &amp;#39;yes&amp;#39; on the card
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CardsMembersVoted
instance A.FromJSON CardsMembersVoted where
  parseJSON = A.withObject "CardsMembersVoted" $ \o ->
    CardsMembersVoted
      <$> (o .:? "value")

-- | ToJSON CardsMembersVoted
instance A.ToJSON CardsMembersVoted where
  toJSON CardsMembersVoted {..} =
   _omitNulls
      [ "value" .= cardsMembersVotedValue
      ]


-- | Construct a value of type 'CardsMembersVoted' (by applying it's required fields, if any)
mkCardsMembersVoted
  :: CardsMembersVoted
mkCardsMembersVoted =
  CardsMembersVoted
  { cardsMembersVotedValue = Nothing
  }

-- ** CardsName
-- | CardsName
data CardsName = CardsName
  { cardsNameValue :: !(Maybe Text) -- ^ "value" - a string with a length from 1 to 16384
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CardsName
instance A.FromJSON CardsName where
  parseJSON = A.withObject "CardsName" $ \o ->
    CardsName
      <$> (o .:? "value")

-- | ToJSON CardsName
instance A.ToJSON CardsName where
  toJSON CardsName {..} =
   _omitNulls
      [ "value" .= cardsNameValue
      ]


-- | Construct a value of type 'CardsName' (by applying it's required fields, if any)
mkCardsName
  :: CardsName
mkCardsName =
  CardsName
  { cardsNameValue = Nothing
  }

-- ** CardsPos
-- | CardsPos
data CardsPos = CardsPos
  { cardsPosValue :: !(Maybe Text) -- ^ "value" - A position. top , bottom , or a positive number.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CardsPos
instance A.FromJSON CardsPos where
  parseJSON = A.withObject "CardsPos" $ \o ->
    CardsPos
      <$> (o .:? "value")

-- | ToJSON CardsPos
instance A.ToJSON CardsPos where
  toJSON CardsPos {..} =
   _omitNulls
      [ "value" .= cardsPosValue
      ]


-- | Construct a value of type 'CardsPos' (by applying it's required fields, if any)
mkCardsPos
  :: CardsPos
mkCardsPos =
  CardsPos
  { cardsPosValue = Nothing
  }

-- ** CardsStickers
-- | CardsStickers
data CardsStickers = CardsStickers
  { cardsStickersImage :: !(Maybe Text) -- ^ "image" - a string with a length from 0 to 16384
  , cardsStickersLeft :: !(Maybe Text) -- ^ "left" - undefined
  , cardsStickersRotate :: !(Maybe Text) -- ^ "rotate" - undefined
  , cardsStickersTop :: !(Maybe Text) -- ^ "top" - undefined
  , cardsStickersZIndex :: !(Maybe Text) -- ^ "zIndex" - Valid Z values for stickers, must be an integer
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CardsStickers
instance A.FromJSON CardsStickers where
  parseJSON = A.withObject "CardsStickers" $ \o ->
    CardsStickers
      <$> (o .:? "image")
      <*> (o .:? "left")
      <*> (o .:? "rotate")
      <*> (o .:? "top")
      <*> (o .:? "zIndex")

-- | ToJSON CardsStickers
instance A.ToJSON CardsStickers where
  toJSON CardsStickers {..} =
   _omitNulls
      [ "image" .= cardsStickersImage
      , "left" .= cardsStickersLeft
      , "rotate" .= cardsStickersRotate
      , "top" .= cardsStickersTop
      , "zIndex" .= cardsStickersZIndex
      ]


-- | Construct a value of type 'CardsStickers' (by applying it's required fields, if any)
mkCardsStickers
  :: CardsStickers
mkCardsStickers =
  CardsStickers
  { cardsStickersImage = Nothing
  , cardsStickersLeft = Nothing
  , cardsStickersRotate = Nothing
  , cardsStickersTop = Nothing
  , cardsStickersZIndex = Nothing
  }

-- ** CardsSubscribed
-- | CardsSubscribed
data CardsSubscribed = CardsSubscribed
  { cardsSubscribedValue :: !(Maybe Text) -- ^ "value" -  true or false
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CardsSubscribed
instance A.FromJSON CardsSubscribed where
  parseJSON = A.withObject "CardsSubscribed" $ \o ->
    CardsSubscribed
      <$> (o .:? "value")

-- | ToJSON CardsSubscribed
instance A.ToJSON CardsSubscribed where
  toJSON CardsSubscribed {..} =
   _omitNulls
      [ "value" .= cardsSubscribedValue
      ]


-- | Construct a value of type 'CardsSubscribed' (by applying it's required fields, if any)
mkCardsSubscribed
  :: CardsSubscribed
mkCardsSubscribed =
  CardsSubscribed
  { cardsSubscribedValue = Nothing
  }

-- ** Checklists
-- | Checklists
data Checklists = Checklists
  { checklistsIdBoard :: !(Maybe Text) -- ^ "idBoard" - id of the board that the checklist should be added to
  , checklistsIdCard :: !(Maybe Text) -- ^ "idCard" - id of the card that the checklist should be added to
  , checklistsIdChecklistSource :: !(Maybe Text) -- ^ "idChecklistSource" - The id of the source checklist to copy into a new checklist.
  , checklistsName :: !(Maybe Text) -- ^ "name" - a string with a length from 0 to 16384
  , checklistsPos :: !(Maybe Text) -- ^ "pos" - A position. top , bottom , or a positive number.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Checklists
instance A.FromJSON Checklists where
  parseJSON = A.withObject "Checklists" $ \o ->
    Checklists
      <$> (o .:? "idBoard")
      <*> (o .:? "idCard")
      <*> (o .:? "idChecklistSource")
      <*> (o .:? "name")
      <*> (o .:? "pos")

-- | ToJSON Checklists
instance A.ToJSON Checklists where
  toJSON Checklists {..} =
   _omitNulls
      [ "idBoard" .= checklistsIdBoard
      , "idCard" .= checklistsIdCard
      , "idChecklistSource" .= checklistsIdChecklistSource
      , "name" .= checklistsName
      , "pos" .= checklistsPos
      ]


-- | Construct a value of type 'Checklists' (by applying it's required fields, if any)
mkChecklists
  :: Checklists
mkChecklists =
  Checklists
  { checklistsIdBoard = Nothing
  , checklistsIdCard = Nothing
  , checklistsIdChecklistSource = Nothing
  , checklistsName = Nothing
  , checklistsPos = Nothing
  }

-- ** ChecklistsCheckItems
-- | ChecklistsCheckItems
data ChecklistsCheckItems = ChecklistsCheckItems
  { checklistsCheckItemsChecked :: !(Maybe Text) -- ^ "checked" -  true or false
  , checklistsCheckItemsName :: !(Maybe Text) -- ^ "name" - a string with a length from 1 to 16384
  , checklistsCheckItemsPos :: !(Maybe Text) -- ^ "pos" - A position. top , bottom , or a positive number.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ChecklistsCheckItems
instance A.FromJSON ChecklistsCheckItems where
  parseJSON = A.withObject "ChecklistsCheckItems" $ \o ->
    ChecklistsCheckItems
      <$> (o .:? "checked")
      <*> (o .:? "name")
      <*> (o .:? "pos")

-- | ToJSON ChecklistsCheckItems
instance A.ToJSON ChecklistsCheckItems where
  toJSON ChecklistsCheckItems {..} =
   _omitNulls
      [ "checked" .= checklistsCheckItemsChecked
      , "name" .= checklistsCheckItemsName
      , "pos" .= checklistsCheckItemsPos
      ]


-- | Construct a value of type 'ChecklistsCheckItems' (by applying it's required fields, if any)
mkChecklistsCheckItems
  :: ChecklistsCheckItems
mkChecklistsCheckItems =
  ChecklistsCheckItems
  { checklistsCheckItemsChecked = Nothing
  , checklistsCheckItemsName = Nothing
  , checklistsCheckItemsPos = Nothing
  }

-- ** ChecklistsIdCard
-- | ChecklistsIdCard
data ChecklistsIdCard = ChecklistsIdCard
  { checklistsIdCardValue :: !(Maybe Text) -- ^ "value" - The id of the card that the checklist is on
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ChecklistsIdCard
instance A.FromJSON ChecklistsIdCard where
  parseJSON = A.withObject "ChecklistsIdCard" $ \o ->
    ChecklistsIdCard
      <$> (o .:? "value")

-- | ToJSON ChecklistsIdCard
instance A.ToJSON ChecklistsIdCard where
  toJSON ChecklistsIdCard {..} =
   _omitNulls
      [ "value" .= checklistsIdCardValue
      ]


-- | Construct a value of type 'ChecklistsIdCard' (by applying it's required fields, if any)
mkChecklistsIdCard
  :: ChecklistsIdCard
mkChecklistsIdCard =
  ChecklistsIdCard
  { checklistsIdCardValue = Nothing
  }

-- ** ChecklistsName
-- | ChecklistsName
data ChecklistsName = ChecklistsName
  { checklistsNameValue :: !(Maybe Text) -- ^ "value" - a string with a length from 1 to 16384
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ChecklistsName
instance A.FromJSON ChecklistsName where
  parseJSON = A.withObject "ChecklistsName" $ \o ->
    ChecklistsName
      <$> (o .:? "value")

-- | ToJSON ChecklistsName
instance A.ToJSON ChecklistsName where
  toJSON ChecklistsName {..} =
   _omitNulls
      [ "value" .= checklistsNameValue
      ]


-- | Construct a value of type 'ChecklistsName' (by applying it's required fields, if any)
mkChecklistsName
  :: ChecklistsName
mkChecklistsName =
  ChecklistsName
  { checklistsNameValue = Nothing
  }

-- ** ChecklistsPos
-- | ChecklistsPos
data ChecklistsPos = ChecklistsPos
  { checklistsPosValue :: !(Maybe Text) -- ^ "value" - A position. top , bottom , or a positive number.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ChecklistsPos
instance A.FromJSON ChecklistsPos where
  parseJSON = A.withObject "ChecklistsPos" $ \o ->
    ChecklistsPos
      <$> (o .:? "value")

-- | ToJSON ChecklistsPos
instance A.ToJSON ChecklistsPos where
  toJSON ChecklistsPos {..} =
   _omitNulls
      [ "value" .= checklistsPosValue
      ]


-- | Construct a value of type 'ChecklistsPos' (by applying it's required fields, if any)
mkChecklistsPos
  :: ChecklistsPos
mkChecklistsPos =
  ChecklistsPos
  { checklistsPosValue = Nothing
  }

-- ** LabelNamesBlue
-- | LabelNamesBlue
data LabelNamesBlue = LabelNamesBlue
  { labelNamesBlueValue :: !(Maybe Text) -- ^ "value" - a string with a length from 0 to 16384
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON LabelNamesBlue
instance A.FromJSON LabelNamesBlue where
  parseJSON = A.withObject "LabelNamesBlue" $ \o ->
    LabelNamesBlue
      <$> (o .:? "value")

-- | ToJSON LabelNamesBlue
instance A.ToJSON LabelNamesBlue where
  toJSON LabelNamesBlue {..} =
   _omitNulls
      [ "value" .= labelNamesBlueValue
      ]


-- | Construct a value of type 'LabelNamesBlue' (by applying it's required fields, if any)
mkLabelNamesBlue
  :: LabelNamesBlue
mkLabelNamesBlue =
  LabelNamesBlue
  { labelNamesBlueValue = Nothing
  }

-- ** LabelNamesGreen
-- | LabelNamesGreen
data LabelNamesGreen = LabelNamesGreen
  { labelNamesGreenValue :: !(Maybe Text) -- ^ "value" - a string with a length from 0 to 16384
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON LabelNamesGreen
instance A.FromJSON LabelNamesGreen where
  parseJSON = A.withObject "LabelNamesGreen" $ \o ->
    LabelNamesGreen
      <$> (o .:? "value")

-- | ToJSON LabelNamesGreen
instance A.ToJSON LabelNamesGreen where
  toJSON LabelNamesGreen {..} =
   _omitNulls
      [ "value" .= labelNamesGreenValue
      ]


-- | Construct a value of type 'LabelNamesGreen' (by applying it's required fields, if any)
mkLabelNamesGreen
  :: LabelNamesGreen
mkLabelNamesGreen =
  LabelNamesGreen
  { labelNamesGreenValue = Nothing
  }

-- ** LabelNamesOrange
-- | LabelNamesOrange
data LabelNamesOrange = LabelNamesOrange
  { labelNamesOrangeValue :: !(Maybe Text) -- ^ "value" - a string with a length from 0 to 16384
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON LabelNamesOrange
instance A.FromJSON LabelNamesOrange where
  parseJSON = A.withObject "LabelNamesOrange" $ \o ->
    LabelNamesOrange
      <$> (o .:? "value")

-- | ToJSON LabelNamesOrange
instance A.ToJSON LabelNamesOrange where
  toJSON LabelNamesOrange {..} =
   _omitNulls
      [ "value" .= labelNamesOrangeValue
      ]


-- | Construct a value of type 'LabelNamesOrange' (by applying it's required fields, if any)
mkLabelNamesOrange
  :: LabelNamesOrange
mkLabelNamesOrange =
  LabelNamesOrange
  { labelNamesOrangeValue = Nothing
  }

-- ** LabelNamesPurple
-- | LabelNamesPurple
data LabelNamesPurple = LabelNamesPurple
  { labelNamesPurpleValue :: !(Maybe Text) -- ^ "value" - a string with a length from 0 to 16384
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON LabelNamesPurple
instance A.FromJSON LabelNamesPurple where
  parseJSON = A.withObject "LabelNamesPurple" $ \o ->
    LabelNamesPurple
      <$> (o .:? "value")

-- | ToJSON LabelNamesPurple
instance A.ToJSON LabelNamesPurple where
  toJSON LabelNamesPurple {..} =
   _omitNulls
      [ "value" .= labelNamesPurpleValue
      ]


-- | Construct a value of type 'LabelNamesPurple' (by applying it's required fields, if any)
mkLabelNamesPurple
  :: LabelNamesPurple
mkLabelNamesPurple =
  LabelNamesPurple
  { labelNamesPurpleValue = Nothing
  }

-- ** LabelNamesRed
-- | LabelNamesRed
data LabelNamesRed = LabelNamesRed
  { labelNamesRedValue :: !(Maybe Text) -- ^ "value" - a string with a length from 0 to 16384
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON LabelNamesRed
instance A.FromJSON LabelNamesRed where
  parseJSON = A.withObject "LabelNamesRed" $ \o ->
    LabelNamesRed
      <$> (o .:? "value")

-- | ToJSON LabelNamesRed
instance A.ToJSON LabelNamesRed where
  toJSON LabelNamesRed {..} =
   _omitNulls
      [ "value" .= labelNamesRedValue
      ]


-- | Construct a value of type 'LabelNamesRed' (by applying it's required fields, if any)
mkLabelNamesRed
  :: LabelNamesRed
mkLabelNamesRed =
  LabelNamesRed
  { labelNamesRedValue = Nothing
  }

-- ** LabelNamesYellow
-- | LabelNamesYellow
data LabelNamesYellow = LabelNamesYellow
  { labelNamesYellowValue :: !(Maybe Text) -- ^ "value" - a string with a length from 0 to 16384
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON LabelNamesYellow
instance A.FromJSON LabelNamesYellow where
  parseJSON = A.withObject "LabelNamesYellow" $ \o ->
    LabelNamesYellow
      <$> (o .:? "value")

-- | ToJSON LabelNamesYellow
instance A.ToJSON LabelNamesYellow where
  toJSON LabelNamesYellow {..} =
   _omitNulls
      [ "value" .= labelNamesYellowValue
      ]


-- | Construct a value of type 'LabelNamesYellow' (by applying it's required fields, if any)
mkLabelNamesYellow
  :: LabelNamesYellow
mkLabelNamesYellow =
  LabelNamesYellow
  { labelNamesYellowValue = Nothing
  }

-- ** Labels
-- | Labels
data Labels = Labels
  { labelsColor :: !(Maybe Text) -- ^ "color" - A valid label color or null
  , labelsIdBoard :: !(Maybe Text) -- ^ "idBoard" - An id
  , labelsName :: !(Maybe Text) -- ^ "name" - a string with a length from 0 to 16384
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Labels
instance A.FromJSON Labels where
  parseJSON = A.withObject "Labels" $ \o ->
    Labels
      <$> (o .:? "color")
      <*> (o .:? "idBoard")
      <*> (o .:? "name")

-- | ToJSON Labels
instance A.ToJSON Labels where
  toJSON Labels {..} =
   _omitNulls
      [ "color" .= labelsColor
      , "idBoard" .= labelsIdBoard
      , "name" .= labelsName
      ]


-- | Construct a value of type 'Labels' (by applying it's required fields, if any)
mkLabels
  :: Labels
mkLabels =
  Labels
  { labelsColor = Nothing
  , labelsIdBoard = Nothing
  , labelsName = Nothing
  }

-- ** LabelsColor
-- | LabelsColor
data LabelsColor = LabelsColor
  { labelsColorValue :: !(Maybe Text) -- ^ "value" - A valid label color or null
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON LabelsColor
instance A.FromJSON LabelsColor where
  parseJSON = A.withObject "LabelsColor" $ \o ->
    LabelsColor
      <$> (o .:? "value")

-- | ToJSON LabelsColor
instance A.ToJSON LabelsColor where
  toJSON LabelsColor {..} =
   _omitNulls
      [ "value" .= labelsColorValue
      ]


-- | Construct a value of type 'LabelsColor' (by applying it's required fields, if any)
mkLabelsColor
  :: LabelsColor
mkLabelsColor =
  LabelsColor
  { labelsColorValue = Nothing
  }

-- ** LabelsName
-- | LabelsName
data LabelsName = LabelsName
  { labelsNameValue :: !(Maybe Text) -- ^ "value" - a string with a length from 0 to 16384
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON LabelsName
instance A.FromJSON LabelsName where
  parseJSON = A.withObject "LabelsName" $ \o ->
    LabelsName
      <$> (o .:? "value")

-- | ToJSON LabelsName
instance A.ToJSON LabelsName where
  toJSON LabelsName {..} =
   _omitNulls
      [ "value" .= labelsNameValue
      ]


-- | Construct a value of type 'LabelsName' (by applying it's required fields, if any)
mkLabelsName
  :: LabelsName
mkLabelsName =
  LabelsName
  { labelsNameValue = Nothing
  }

-- ** Lists
-- | Lists
data Lists = Lists
  { listsClosed :: !(Maybe Text) -- ^ "closed" -  true or false
  , listsIdBoard :: !(Maybe Text) -- ^ "idBoard" - id of the board that the list should be added to
  , listsIdListSource :: !(Maybe Text) -- ^ "idListSource" - The id of the list to copy into a new list.
  , listsName :: !(Maybe Text) -- ^ "name" - a string with a length from 1 to 16384
  , listsPos :: !(Maybe Text) -- ^ "pos" - A position. top , bottom , or a positive number.
  , listsSubscribed :: !(Maybe Text) -- ^ "subscribed" -  true or false
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Lists
instance A.FromJSON Lists where
  parseJSON = A.withObject "Lists" $ \o ->
    Lists
      <$> (o .:? "closed")
      <*> (o .:? "idBoard")
      <*> (o .:? "idListSource")
      <*> (o .:? "name")
      <*> (o .:? "pos")
      <*> (o .:? "subscribed")

-- | ToJSON Lists
instance A.ToJSON Lists where
  toJSON Lists {..} =
   _omitNulls
      [ "closed" .= listsClosed
      , "idBoard" .= listsIdBoard
      , "idListSource" .= listsIdListSource
      , "name" .= listsName
      , "pos" .= listsPos
      , "subscribed" .= listsSubscribed
      ]


-- | Construct a value of type 'Lists' (by applying it's required fields, if any)
mkLists
  :: Lists
mkLists =
  Lists
  { listsClosed = Nothing
  , listsIdBoard = Nothing
  , listsIdListSource = Nothing
  , listsName = Nothing
  , listsPos = Nothing
  , listsSubscribed = Nothing
  }

-- ** ListsCards
-- | ListsCards
data ListsCards = ListsCards
  { listsCardsDesc :: !(Maybe Text) -- ^ "desc" - a string with a length from 0 to 16384
  , listsCardsDue :: !(Maybe Text) -- ^ "due" - A date, or null
  , listsCardsIdMembers :: !(Maybe Text) -- ^ "idMembers" - A comma-separated list of objectIds, 24-character hex strings
  , listsCardsLabels :: !(Maybe Text) -- ^ "labels" - all or a comma-separated list of: blue, green, orange, purple, red or yellow
  , listsCardsName :: !(Maybe Text) -- ^ "name" - a string with a length from 1 to 16384
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ListsCards
instance A.FromJSON ListsCards where
  parseJSON = A.withObject "ListsCards" $ \o ->
    ListsCards
      <$> (o .:? "desc")
      <*> (o .:? "due")
      <*> (o .:? "idMembers")
      <*> (o .:? "labels")
      <*> (o .:? "name")

-- | ToJSON ListsCards
instance A.ToJSON ListsCards where
  toJSON ListsCards {..} =
   _omitNulls
      [ "desc" .= listsCardsDesc
      , "due" .= listsCardsDue
      , "idMembers" .= listsCardsIdMembers
      , "labels" .= listsCardsLabels
      , "name" .= listsCardsName
      ]


-- | Construct a value of type 'ListsCards' (by applying it's required fields, if any)
mkListsCards
  :: ListsCards
mkListsCards =
  ListsCards
  { listsCardsDesc = Nothing
  , listsCardsDue = Nothing
  , listsCardsIdMembers = Nothing
  , listsCardsLabels = Nothing
  , listsCardsName = Nothing
  }

-- ** ListsClosed
-- | ListsClosed
data ListsClosed = ListsClosed
  { listsClosedValue :: !(Maybe Text) -- ^ "value" -  true or false
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ListsClosed
instance A.FromJSON ListsClosed where
  parseJSON = A.withObject "ListsClosed" $ \o ->
    ListsClosed
      <$> (o .:? "value")

-- | ToJSON ListsClosed
instance A.ToJSON ListsClosed where
  toJSON ListsClosed {..} =
   _omitNulls
      [ "value" .= listsClosedValue
      ]


-- | Construct a value of type 'ListsClosed' (by applying it's required fields, if any)
mkListsClosed
  :: ListsClosed
mkListsClosed =
  ListsClosed
  { listsClosedValue = Nothing
  }

-- ** ListsIdBoard
-- | ListsIdBoard
data ListsIdBoard = ListsIdBoard
  { listsIdBoardPos :: !(Maybe Text) -- ^ "pos" - position of the list on the new board
  , listsIdBoardValue :: !(Maybe Text) -- ^ "value" - id of the board the list should be moved to
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ListsIdBoard
instance A.FromJSON ListsIdBoard where
  parseJSON = A.withObject "ListsIdBoard" $ \o ->
    ListsIdBoard
      <$> (o .:? "pos")
      <*> (o .:? "value")

-- | ToJSON ListsIdBoard
instance A.ToJSON ListsIdBoard where
  toJSON ListsIdBoard {..} =
   _omitNulls
      [ "pos" .= listsIdBoardPos
      , "value" .= listsIdBoardValue
      ]


-- | Construct a value of type 'ListsIdBoard' (by applying it's required fields, if any)
mkListsIdBoard
  :: ListsIdBoard
mkListsIdBoard =
  ListsIdBoard
  { listsIdBoardPos = Nothing
  , listsIdBoardValue = Nothing
  }

-- ** ListsMoveAllCards
-- | ListsMoveAllCards
data ListsMoveAllCards = ListsMoveAllCards
  { listsMoveAllCardsIdBoard :: !(Maybe Text) -- ^ "idBoard" - id of the board that the cards should be moved to
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ListsMoveAllCards
instance A.FromJSON ListsMoveAllCards where
  parseJSON = A.withObject "ListsMoveAllCards" $ \o ->
    ListsMoveAllCards
      <$> (o .:? "idBoard")

-- | ToJSON ListsMoveAllCards
instance A.ToJSON ListsMoveAllCards where
  toJSON ListsMoveAllCards {..} =
   _omitNulls
      [ "idBoard" .= listsMoveAllCardsIdBoard
      ]


-- | Construct a value of type 'ListsMoveAllCards' (by applying it's required fields, if any)
mkListsMoveAllCards
  :: ListsMoveAllCards
mkListsMoveAllCards =
  ListsMoveAllCards
  { listsMoveAllCardsIdBoard = Nothing
  }

-- ** ListsName
-- | ListsName
data ListsName = ListsName
  { listsNameValue :: !(Maybe Text) -- ^ "value" - a string with a length from 1 to 16384
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ListsName
instance A.FromJSON ListsName where
  parseJSON = A.withObject "ListsName" $ \o ->
    ListsName
      <$> (o .:? "value")

-- | ToJSON ListsName
instance A.ToJSON ListsName where
  toJSON ListsName {..} =
   _omitNulls
      [ "value" .= listsNameValue
      ]


-- | Construct a value of type 'ListsName' (by applying it's required fields, if any)
mkListsName
  :: ListsName
mkListsName =
  ListsName
  { listsNameValue = Nothing
  }

-- ** ListsPos
-- | ListsPos
data ListsPos = ListsPos
  { listsPosValue :: !(Maybe Text) -- ^ "value" - A position. top , bottom , or a positive number.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ListsPos
instance A.FromJSON ListsPos where
  parseJSON = A.withObject "ListsPos" $ \o ->
    ListsPos
      <$> (o .:? "value")

-- | ToJSON ListsPos
instance A.ToJSON ListsPos where
  toJSON ListsPos {..} =
   _omitNulls
      [ "value" .= listsPosValue
      ]


-- | Construct a value of type 'ListsPos' (by applying it's required fields, if any)
mkListsPos
  :: ListsPos
mkListsPos =
  ListsPos
  { listsPosValue = Nothing
  }

-- ** ListsSubscribed
-- | ListsSubscribed
data ListsSubscribed = ListsSubscribed
  { listsSubscribedValue :: !(Maybe Text) -- ^ "value" -  true or false
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ListsSubscribed
instance A.FromJSON ListsSubscribed where
  parseJSON = A.withObject "ListsSubscribed" $ \o ->
    ListsSubscribed
      <$> (o .:? "value")

-- | ToJSON ListsSubscribed
instance A.ToJSON ListsSubscribed where
  toJSON ListsSubscribed {..} =
   _omitNulls
      [ "value" .= listsSubscribedValue
      ]


-- | Construct a value of type 'ListsSubscribed' (by applying it's required fields, if any)
mkListsSubscribed
  :: ListsSubscribed
mkListsSubscribed =
  ListsSubscribed
  { listsSubscribedValue = Nothing
  }

-- ** Members
-- | Members
data Members = Members
  { membersAvatarSource :: !(Maybe Text) -- ^ "avatarSource" - One of: gravatar, none or upload
  , membersBio :: !(Maybe Text) -- ^ "bio" - a string with a length from 0 to 16384
  , membersFullName :: !(Maybe Text) -- ^ "fullName" - A string with a length of at least 1.  Cannot begin or end with a space.
  , membersInitials :: !(Maybe Text) -- ^ "initials" - A string with a length from 1 to 4.  Cannot begin or end with a space
  , membersPrefscolorBlind :: !(Maybe Text) -- ^ "prefs/colorBlind" -  true or false
  , membersPrefslocale :: !(Maybe Text) -- ^ "prefs/locale" - a string with a length from 0 to 255
  , membersPrefsminutesBetweenSummaries :: !(Maybe Text) -- ^ "prefs/minutesBetweenSummaries" - -1 (disabled), 1 or 60
  , membersUsername :: !(Maybe Text) -- ^ "username" - A string with a length of at least 3.  Only lowercase letters, underscores, and numbers are allowed.  Must be unique.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Members
instance A.FromJSON Members where
  parseJSON = A.withObject "Members" $ \o ->
    Members
      <$> (o .:? "avatarSource")
      <*> (o .:? "bio")
      <*> (o .:? "fullName")
      <*> (o .:? "initials")
      <*> (o .:? "prefs/colorBlind")
      <*> (o .:? "prefs/locale")
      <*> (o .:? "prefs/minutesBetweenSummaries")
      <*> (o .:? "username")

-- | ToJSON Members
instance A.ToJSON Members where
  toJSON Members {..} =
   _omitNulls
      [ "avatarSource" .= membersAvatarSource
      , "bio" .= membersBio
      , "fullName" .= membersFullName
      , "initials" .= membersInitials
      , "prefs/colorBlind" .= membersPrefscolorBlind
      , "prefs/locale" .= membersPrefslocale
      , "prefs/minutesBetweenSummaries" .= membersPrefsminutesBetweenSummaries
      , "username" .= membersUsername
      ]


-- | Construct a value of type 'Members' (by applying it's required fields, if any)
mkMembers
  :: Members
mkMembers =
  Members
  { membersAvatarSource = Nothing
  , membersBio = Nothing
  , membersFullName = Nothing
  , membersInitials = Nothing
  , membersPrefscolorBlind = Nothing
  , membersPrefslocale = Nothing
  , membersPrefsminutesBetweenSummaries = Nothing
  , membersUsername = Nothing
  }

-- ** MembersAvatar
-- | MembersAvatar
data MembersAvatar = MembersAvatar
  { membersAvatarFile :: !(Maybe Text) -- ^ "file" - A file
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MembersAvatar
instance A.FromJSON MembersAvatar where
  parseJSON = A.withObject "MembersAvatar" $ \o ->
    MembersAvatar
      <$> (o .:? "file")

-- | ToJSON MembersAvatar
instance A.ToJSON MembersAvatar where
  toJSON MembersAvatar {..} =
   _omitNulls
      [ "file" .= membersAvatarFile
      ]


-- | Construct a value of type 'MembersAvatar' (by applying it's required fields, if any)
mkMembersAvatar
  :: MembersAvatar
mkMembersAvatar =
  MembersAvatar
  { membersAvatarFile = Nothing
  }

-- ** MembersAvatarSource
-- | MembersAvatarSource
data MembersAvatarSource = MembersAvatarSource
  { membersAvatarSourceValue :: !(Maybe Text) -- ^ "value" - One of: gravatar, none or upload
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MembersAvatarSource
instance A.FromJSON MembersAvatarSource where
  parseJSON = A.withObject "MembersAvatarSource" $ \o ->
    MembersAvatarSource
      <$> (o .:? "value")

-- | ToJSON MembersAvatarSource
instance A.ToJSON MembersAvatarSource where
  toJSON MembersAvatarSource {..} =
   _omitNulls
      [ "value" .= membersAvatarSourceValue
      ]


-- | Construct a value of type 'MembersAvatarSource' (by applying it's required fields, if any)
mkMembersAvatarSource
  :: MembersAvatarSource
mkMembersAvatarSource =
  MembersAvatarSource
  { membersAvatarSourceValue = Nothing
  }

-- ** MembersBio
-- | MembersBio
data MembersBio = MembersBio
  { membersBioValue :: !(Maybe Text) -- ^ "value" - a string with a length from 0 to 16384
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MembersBio
instance A.FromJSON MembersBio where
  parseJSON = A.withObject "MembersBio" $ \o ->
    MembersBio
      <$> (o .:? "value")

-- | ToJSON MembersBio
instance A.ToJSON MembersBio where
  toJSON MembersBio {..} =
   _omitNulls
      [ "value" .= membersBioValue
      ]


-- | Construct a value of type 'MembersBio' (by applying it's required fields, if any)
mkMembersBio
  :: MembersBio
mkMembersBio =
  MembersBio
  { membersBioValue = Nothing
  }

-- ** MembersBoardBackgrounds
-- | MembersBoardBackgrounds
data MembersBoardBackgrounds = MembersBoardBackgrounds
  { membersBoardBackgroundsBrightness :: !(Maybe Text) -- ^ "brightness" - One of: dark, light or unknown
  , membersBoardBackgroundsFile :: !(Maybe Text) -- ^ "file" - A file
  , membersBoardBackgroundsTile :: !(Maybe Text) -- ^ "tile" -  true or false
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MembersBoardBackgrounds
instance A.FromJSON MembersBoardBackgrounds where
  parseJSON = A.withObject "MembersBoardBackgrounds" $ \o ->
    MembersBoardBackgrounds
      <$> (o .:? "brightness")
      <*> (o .:? "file")
      <*> (o .:? "tile")

-- | ToJSON MembersBoardBackgrounds
instance A.ToJSON MembersBoardBackgrounds where
  toJSON MembersBoardBackgrounds {..} =
   _omitNulls
      [ "brightness" .= membersBoardBackgroundsBrightness
      , "file" .= membersBoardBackgroundsFile
      , "tile" .= membersBoardBackgroundsTile
      ]


-- | Construct a value of type 'MembersBoardBackgrounds' (by applying it's required fields, if any)
mkMembersBoardBackgrounds
  :: MembersBoardBackgrounds
mkMembersBoardBackgrounds =
  MembersBoardBackgrounds
  { membersBoardBackgroundsBrightness = Nothing
  , membersBoardBackgroundsFile = Nothing
  , membersBoardBackgroundsTile = Nothing
  }

-- ** MembersBoardStars
-- | MembersBoardStars
data MembersBoardStars = MembersBoardStars
  { membersBoardStarsIdBoard :: !(Maybe Text) -- ^ "idBoard" - The id of the board to star
  , membersBoardStarsPos :: !(Maybe Text) -- ^ "pos" - A position. top , bottom , or a positive number.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MembersBoardStars
instance A.FromJSON MembersBoardStars where
  parseJSON = A.withObject "MembersBoardStars" $ \o ->
    MembersBoardStars
      <$> (o .:? "idBoard")
      <*> (o .:? "pos")

-- | ToJSON MembersBoardStars
instance A.ToJSON MembersBoardStars where
  toJSON MembersBoardStars {..} =
   _omitNulls
      [ "idBoard" .= membersBoardStarsIdBoard
      , "pos" .= membersBoardStarsPos
      ]


-- | Construct a value of type 'MembersBoardStars' (by applying it's required fields, if any)
mkMembersBoardStars
  :: MembersBoardStars
mkMembersBoardStars =
  MembersBoardStars
  { membersBoardStarsIdBoard = Nothing
  , membersBoardStarsPos = Nothing
  }

-- ** MembersBoardStarsIdBoard
-- | MembersBoardStarsIdBoard
data MembersBoardStarsIdBoard = MembersBoardStarsIdBoard
  { membersBoardStarsIdBoardValue :: !(Maybe Text) -- ^ "value" - An id
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MembersBoardStarsIdBoard
instance A.FromJSON MembersBoardStarsIdBoard where
  parseJSON = A.withObject "MembersBoardStarsIdBoard" $ \o ->
    MembersBoardStarsIdBoard
      <$> (o .:? "value")

-- | ToJSON MembersBoardStarsIdBoard
instance A.ToJSON MembersBoardStarsIdBoard where
  toJSON MembersBoardStarsIdBoard {..} =
   _omitNulls
      [ "value" .= membersBoardStarsIdBoardValue
      ]


-- | Construct a value of type 'MembersBoardStarsIdBoard' (by applying it's required fields, if any)
mkMembersBoardStarsIdBoard
  :: MembersBoardStarsIdBoard
mkMembersBoardStarsIdBoard =
  MembersBoardStarsIdBoard
  { membersBoardStarsIdBoardValue = Nothing
  }

-- ** MembersBoardStarsPos
-- | MembersBoardStarsPos
data MembersBoardStarsPos = MembersBoardStarsPos
  { membersBoardStarsPosValue :: !(Maybe Text) -- ^ "value" - A position. top , bottom , or a positive number.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MembersBoardStarsPos
instance A.FromJSON MembersBoardStarsPos where
  parseJSON = A.withObject "MembersBoardStarsPos" $ \o ->
    MembersBoardStarsPos
      <$> (o .:? "value")

-- | ToJSON MembersBoardStarsPos
instance A.ToJSON MembersBoardStarsPos where
  toJSON MembersBoardStarsPos {..} =
   _omitNulls
      [ "value" .= membersBoardStarsPosValue
      ]


-- | Construct a value of type 'MembersBoardStarsPos' (by applying it's required fields, if any)
mkMembersBoardStarsPos
  :: MembersBoardStarsPos
mkMembersBoardStarsPos =
  MembersBoardStarsPos
  { membersBoardStarsPosValue = Nothing
  }

-- ** MembersCustomBoardBackgrounds
-- | MembersCustomBoardBackgrounds
data MembersCustomBoardBackgrounds = MembersCustomBoardBackgrounds
  { membersCustomBoardBackgroundsBrightness :: !(Maybe Text) -- ^ "brightness" - One of: dark, light or unknown
  , membersCustomBoardBackgroundsFile :: !(Maybe Text) -- ^ "file" - A file
  , membersCustomBoardBackgroundsTile :: !(Maybe Text) -- ^ "tile" -  true or false
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MembersCustomBoardBackgrounds
instance A.FromJSON MembersCustomBoardBackgrounds where
  parseJSON = A.withObject "MembersCustomBoardBackgrounds" $ \o ->
    MembersCustomBoardBackgrounds
      <$> (o .:? "brightness")
      <*> (o .:? "file")
      <*> (o .:? "tile")

-- | ToJSON MembersCustomBoardBackgrounds
instance A.ToJSON MembersCustomBoardBackgrounds where
  toJSON MembersCustomBoardBackgrounds {..} =
   _omitNulls
      [ "brightness" .= membersCustomBoardBackgroundsBrightness
      , "file" .= membersCustomBoardBackgroundsFile
      , "tile" .= membersCustomBoardBackgroundsTile
      ]


-- | Construct a value of type 'MembersCustomBoardBackgrounds' (by applying it's required fields, if any)
mkMembersCustomBoardBackgrounds
  :: MembersCustomBoardBackgrounds
mkMembersCustomBoardBackgrounds =
  MembersCustomBoardBackgrounds
  { membersCustomBoardBackgroundsBrightness = Nothing
  , membersCustomBoardBackgroundsFile = Nothing
  , membersCustomBoardBackgroundsTile = Nothing
  }

-- ** MembersCustomEmoji
-- | MembersCustomEmoji
data MembersCustomEmoji = MembersCustomEmoji
  { membersCustomEmojiFile :: !(Maybe Text) -- ^ "file" - A file
  , membersCustomEmojiName :: !(Maybe Text) -- ^ "name" - a string with a length from 2 to 64
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MembersCustomEmoji
instance A.FromJSON MembersCustomEmoji where
  parseJSON = A.withObject "MembersCustomEmoji" $ \o ->
    MembersCustomEmoji
      <$> (o .:? "file")
      <*> (o .:? "name")

-- | ToJSON MembersCustomEmoji
instance A.ToJSON MembersCustomEmoji where
  toJSON MembersCustomEmoji {..} =
   _omitNulls
      [ "file" .= membersCustomEmojiFile
      , "name" .= membersCustomEmojiName
      ]


-- | Construct a value of type 'MembersCustomEmoji' (by applying it's required fields, if any)
mkMembersCustomEmoji
  :: MembersCustomEmoji
mkMembersCustomEmoji =
  MembersCustomEmoji
  { membersCustomEmojiFile = Nothing
  , membersCustomEmojiName = Nothing
  }

-- ** MembersCustomStickers
-- | MembersCustomStickers
data MembersCustomStickers = MembersCustomStickers
  { membersCustomStickersFile :: !(Maybe Text) -- ^ "file" - A file
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MembersCustomStickers
instance A.FromJSON MembersCustomStickers where
  parseJSON = A.withObject "MembersCustomStickers" $ \o ->
    MembersCustomStickers
      <$> (o .:? "file")

-- | ToJSON MembersCustomStickers
instance A.ToJSON MembersCustomStickers where
  toJSON MembersCustomStickers {..} =
   _omitNulls
      [ "file" .= membersCustomStickersFile
      ]


-- | Construct a value of type 'MembersCustomStickers' (by applying it's required fields, if any)
mkMembersCustomStickers
  :: MembersCustomStickers
mkMembersCustomStickers =
  MembersCustomStickers
  { membersCustomStickersFile = Nothing
  }

-- ** MembersFullName
-- | MembersFullName
data MembersFullName = MembersFullName
  { membersFullNameValue :: !(Maybe Text) -- ^ "value" - A string with a length of at least 1.  Cannot begin or end with a space.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MembersFullName
instance A.FromJSON MembersFullName where
  parseJSON = A.withObject "MembersFullName" $ \o ->
    MembersFullName
      <$> (o .:? "value")

-- | ToJSON MembersFullName
instance A.ToJSON MembersFullName where
  toJSON MembersFullName {..} =
   _omitNulls
      [ "value" .= membersFullNameValue
      ]


-- | Construct a value of type 'MembersFullName' (by applying it's required fields, if any)
mkMembersFullName
  :: MembersFullName
mkMembersFullName =
  MembersFullName
  { membersFullNameValue = Nothing
  }

-- ** MembersInitials
-- | MembersInitials
data MembersInitials = MembersInitials
  { membersInitialsValue :: !(Maybe Text) -- ^ "value" - A string with a length from 1 to 4.  Cannot begin or end with a space
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MembersInitials
instance A.FromJSON MembersInitials where
  parseJSON = A.withObject "MembersInitials" $ \o ->
    MembersInitials
      <$> (o .:? "value")

-- | ToJSON MembersInitials
instance A.ToJSON MembersInitials where
  toJSON MembersInitials {..} =
   _omitNulls
      [ "value" .= membersInitialsValue
      ]


-- | Construct a value of type 'MembersInitials' (by applying it's required fields, if any)
mkMembersInitials
  :: MembersInitials
mkMembersInitials =
  MembersInitials
  { membersInitialsValue = Nothing
  }

-- ** MembersOneTimeMessagesDismissed
-- | MembersOneTimeMessagesDismissed
data MembersOneTimeMessagesDismissed = MembersOneTimeMessagesDismissed
  { membersOneTimeMessagesDismissedValue :: !(Maybe Text) -- ^ "value" - Type of message dismissed
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MembersOneTimeMessagesDismissed
instance A.FromJSON MembersOneTimeMessagesDismissed where
  parseJSON = A.withObject "MembersOneTimeMessagesDismissed" $ \o ->
    MembersOneTimeMessagesDismissed
      <$> (o .:? "value")

-- | ToJSON MembersOneTimeMessagesDismissed
instance A.ToJSON MembersOneTimeMessagesDismissed where
  toJSON MembersOneTimeMessagesDismissed {..} =
   _omitNulls
      [ "value" .= membersOneTimeMessagesDismissedValue
      ]


-- | Construct a value of type 'MembersOneTimeMessagesDismissed' (by applying it's required fields, if any)
mkMembersOneTimeMessagesDismissed
  :: MembersOneTimeMessagesDismissed
mkMembersOneTimeMessagesDismissed =
  MembersOneTimeMessagesDismissed
  { membersOneTimeMessagesDismissedValue = Nothing
  }

-- ** MembersSavedSearches
-- | MembersSavedSearches
data MembersSavedSearches = MembersSavedSearches
  { membersSavedSearchesName :: !(Maybe Text) -- ^ "name" - A non-empty string with at least one non-space character
  , membersSavedSearchesPos :: !(Maybe Text) -- ^ "pos" - A position. top , bottom , or a positive number.
  , membersSavedSearchesQuery :: !(Maybe Text) -- ^ "query" - a string with a length from 1 to 16384
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MembersSavedSearches
instance A.FromJSON MembersSavedSearches where
  parseJSON = A.withObject "MembersSavedSearches" $ \o ->
    MembersSavedSearches
      <$> (o .:? "name")
      <*> (o .:? "pos")
      <*> (o .:? "query")

-- | ToJSON MembersSavedSearches
instance A.ToJSON MembersSavedSearches where
  toJSON MembersSavedSearches {..} =
   _omitNulls
      [ "name" .= membersSavedSearchesName
      , "pos" .= membersSavedSearchesPos
      , "query" .= membersSavedSearchesQuery
      ]


-- | Construct a value of type 'MembersSavedSearches' (by applying it's required fields, if any)
mkMembersSavedSearches
  :: MembersSavedSearches
mkMembersSavedSearches =
  MembersSavedSearches
  { membersSavedSearchesName = Nothing
  , membersSavedSearchesPos = Nothing
  , membersSavedSearchesQuery = Nothing
  }

-- ** MembersSavedSearchesName
-- | MembersSavedSearchesName
data MembersSavedSearchesName = MembersSavedSearchesName
  { membersSavedSearchesNameValue :: !(Maybe Text) -- ^ "value" - A non-empty string with at least one non-space character
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MembersSavedSearchesName
instance A.FromJSON MembersSavedSearchesName where
  parseJSON = A.withObject "MembersSavedSearchesName" $ \o ->
    MembersSavedSearchesName
      <$> (o .:? "value")

-- | ToJSON MembersSavedSearchesName
instance A.ToJSON MembersSavedSearchesName where
  toJSON MembersSavedSearchesName {..} =
   _omitNulls
      [ "value" .= membersSavedSearchesNameValue
      ]


-- | Construct a value of type 'MembersSavedSearchesName' (by applying it's required fields, if any)
mkMembersSavedSearchesName
  :: MembersSavedSearchesName
mkMembersSavedSearchesName =
  MembersSavedSearchesName
  { membersSavedSearchesNameValue = Nothing
  }

-- ** MembersSavedSearchesPos
-- | MembersSavedSearchesPos
data MembersSavedSearchesPos = MembersSavedSearchesPos
  { membersSavedSearchesPosValue :: !(Maybe Text) -- ^ "value" - A position. top , bottom , or a positive number.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MembersSavedSearchesPos
instance A.FromJSON MembersSavedSearchesPos where
  parseJSON = A.withObject "MembersSavedSearchesPos" $ \o ->
    MembersSavedSearchesPos
      <$> (o .:? "value")

-- | ToJSON MembersSavedSearchesPos
instance A.ToJSON MembersSavedSearchesPos where
  toJSON MembersSavedSearchesPos {..} =
   _omitNulls
      [ "value" .= membersSavedSearchesPosValue
      ]


-- | Construct a value of type 'MembersSavedSearchesPos' (by applying it's required fields, if any)
mkMembersSavedSearchesPos
  :: MembersSavedSearchesPos
mkMembersSavedSearchesPos =
  MembersSavedSearchesPos
  { membersSavedSearchesPosValue = Nothing
  }

-- ** MembersSavedSearchesQuery
-- | MembersSavedSearchesQuery
data MembersSavedSearchesQuery = MembersSavedSearchesQuery
  { membersSavedSearchesQueryValue :: !(Maybe Text) -- ^ "value" - a string with a length from 1 to 16384
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MembersSavedSearchesQuery
instance A.FromJSON MembersSavedSearchesQuery where
  parseJSON = A.withObject "MembersSavedSearchesQuery" $ \o ->
    MembersSavedSearchesQuery
      <$> (o .:? "value")

-- | ToJSON MembersSavedSearchesQuery
instance A.ToJSON MembersSavedSearchesQuery where
  toJSON MembersSavedSearchesQuery {..} =
   _omitNulls
      [ "value" .= membersSavedSearchesQueryValue
      ]


-- | Construct a value of type 'MembersSavedSearchesQuery' (by applying it's required fields, if any)
mkMembersSavedSearchesQuery
  :: MembersSavedSearchesQuery
mkMembersSavedSearchesQuery =
  MembersSavedSearchesQuery
  { membersSavedSearchesQueryValue = Nothing
  }

-- ** MembersUsername
-- | MembersUsername
data MembersUsername = MembersUsername
  { membersUsernameValue :: !(Maybe Text) -- ^ "value" - A string with a length of at least 3.  Only lowercase letters, underscores, and numbers are allowed.  Must be unique.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MembersUsername
instance A.FromJSON MembersUsername where
  parseJSON = A.withObject "MembersUsername" $ \o ->
    MembersUsername
      <$> (o .:? "value")

-- | ToJSON MembersUsername
instance A.ToJSON MembersUsername where
  toJSON MembersUsername {..} =
   _omitNulls
      [ "value" .= membersUsernameValue
      ]


-- | Construct a value of type 'MembersUsername' (by applying it's required fields, if any)
mkMembersUsername
  :: MembersUsername
mkMembersUsername =
  MembersUsername
  { membersUsernameValue = Nothing
  }

-- ** MyPrefsEmailPosition
-- | MyPrefsEmailPosition
data MyPrefsEmailPosition = MyPrefsEmailPosition
  { myPrefsEmailPositionValue :: !(Maybe Text) -- ^ "value" - One of: bottom or top
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MyPrefsEmailPosition
instance A.FromJSON MyPrefsEmailPosition where
  parseJSON = A.withObject "MyPrefsEmailPosition" $ \o ->
    MyPrefsEmailPosition
      <$> (o .:? "value")

-- | ToJSON MyPrefsEmailPosition
instance A.ToJSON MyPrefsEmailPosition where
  toJSON MyPrefsEmailPosition {..} =
   _omitNulls
      [ "value" .= myPrefsEmailPositionValue
      ]


-- | Construct a value of type 'MyPrefsEmailPosition' (by applying it's required fields, if any)
mkMyPrefsEmailPosition
  :: MyPrefsEmailPosition
mkMyPrefsEmailPosition =
  MyPrefsEmailPosition
  { myPrefsEmailPositionValue = Nothing
  }

-- ** MyPrefsIdEmailList
-- | MyPrefsIdEmailList
data MyPrefsIdEmailList = MyPrefsIdEmailList
  { myPrefsIdEmailListValue :: !(Maybe Text) -- ^ "value" - An id
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MyPrefsIdEmailList
instance A.FromJSON MyPrefsIdEmailList where
  parseJSON = A.withObject "MyPrefsIdEmailList" $ \o ->
    MyPrefsIdEmailList
      <$> (o .:? "value")

-- | ToJSON MyPrefsIdEmailList
instance A.ToJSON MyPrefsIdEmailList where
  toJSON MyPrefsIdEmailList {..} =
   _omitNulls
      [ "value" .= myPrefsIdEmailListValue
      ]


-- | Construct a value of type 'MyPrefsIdEmailList' (by applying it's required fields, if any)
mkMyPrefsIdEmailList
  :: MyPrefsIdEmailList
mkMyPrefsIdEmailList =
  MyPrefsIdEmailList
  { myPrefsIdEmailListValue = Nothing
  }

-- ** MyPrefsShowListGuide
-- | MyPrefsShowListGuide
data MyPrefsShowListGuide = MyPrefsShowListGuide
  { myPrefsShowListGuideValue :: !(Maybe Text) -- ^ "value" -  true or false
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MyPrefsShowListGuide
instance A.FromJSON MyPrefsShowListGuide where
  parseJSON = A.withObject "MyPrefsShowListGuide" $ \o ->
    MyPrefsShowListGuide
      <$> (o .:? "value")

-- | ToJSON MyPrefsShowListGuide
instance A.ToJSON MyPrefsShowListGuide where
  toJSON MyPrefsShowListGuide {..} =
   _omitNulls
      [ "value" .= myPrefsShowListGuideValue
      ]


-- | Construct a value of type 'MyPrefsShowListGuide' (by applying it's required fields, if any)
mkMyPrefsShowListGuide
  :: MyPrefsShowListGuide
mkMyPrefsShowListGuide =
  MyPrefsShowListGuide
  { myPrefsShowListGuideValue = Nothing
  }

-- ** MyPrefsShowSidebar
-- | MyPrefsShowSidebar
data MyPrefsShowSidebar = MyPrefsShowSidebar
  { myPrefsShowSidebarValue :: !(Maybe Text) -- ^ "value" -  true or false
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MyPrefsShowSidebar
instance A.FromJSON MyPrefsShowSidebar where
  parseJSON = A.withObject "MyPrefsShowSidebar" $ \o ->
    MyPrefsShowSidebar
      <$> (o .:? "value")

-- | ToJSON MyPrefsShowSidebar
instance A.ToJSON MyPrefsShowSidebar where
  toJSON MyPrefsShowSidebar {..} =
   _omitNulls
      [ "value" .= myPrefsShowSidebarValue
      ]


-- | Construct a value of type 'MyPrefsShowSidebar' (by applying it's required fields, if any)
mkMyPrefsShowSidebar
  :: MyPrefsShowSidebar
mkMyPrefsShowSidebar =
  MyPrefsShowSidebar
  { myPrefsShowSidebarValue = Nothing
  }

-- ** MyPrefsShowSidebarActivity
-- | MyPrefsShowSidebarActivity
data MyPrefsShowSidebarActivity = MyPrefsShowSidebarActivity
  { myPrefsShowSidebarActivityValue :: !(Maybe Text) -- ^ "value" -  true or false
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MyPrefsShowSidebarActivity
instance A.FromJSON MyPrefsShowSidebarActivity where
  parseJSON = A.withObject "MyPrefsShowSidebarActivity" $ \o ->
    MyPrefsShowSidebarActivity
      <$> (o .:? "value")

-- | ToJSON MyPrefsShowSidebarActivity
instance A.ToJSON MyPrefsShowSidebarActivity where
  toJSON MyPrefsShowSidebarActivity {..} =
   _omitNulls
      [ "value" .= myPrefsShowSidebarActivityValue
      ]


-- | Construct a value of type 'MyPrefsShowSidebarActivity' (by applying it's required fields, if any)
mkMyPrefsShowSidebarActivity
  :: MyPrefsShowSidebarActivity
mkMyPrefsShowSidebarActivity =
  MyPrefsShowSidebarActivity
  { myPrefsShowSidebarActivityValue = Nothing
  }

-- ** MyPrefsShowSidebarBoardActions
-- | MyPrefsShowSidebarBoardActions
data MyPrefsShowSidebarBoardActions = MyPrefsShowSidebarBoardActions
  { myPrefsShowSidebarBoardActionsValue :: !(Maybe Text) -- ^ "value" -  true or false
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MyPrefsShowSidebarBoardActions
instance A.FromJSON MyPrefsShowSidebarBoardActions where
  parseJSON = A.withObject "MyPrefsShowSidebarBoardActions" $ \o ->
    MyPrefsShowSidebarBoardActions
      <$> (o .:? "value")

-- | ToJSON MyPrefsShowSidebarBoardActions
instance A.ToJSON MyPrefsShowSidebarBoardActions where
  toJSON MyPrefsShowSidebarBoardActions {..} =
   _omitNulls
      [ "value" .= myPrefsShowSidebarBoardActionsValue
      ]


-- | Construct a value of type 'MyPrefsShowSidebarBoardActions' (by applying it's required fields, if any)
mkMyPrefsShowSidebarBoardActions
  :: MyPrefsShowSidebarBoardActions
mkMyPrefsShowSidebarBoardActions =
  MyPrefsShowSidebarBoardActions
  { myPrefsShowSidebarBoardActionsValue = Nothing
  }

-- ** MyPrefsShowSidebarMembers
-- | MyPrefsShowSidebarMembers
data MyPrefsShowSidebarMembers = MyPrefsShowSidebarMembers
  { myPrefsShowSidebarMembersValue :: !(Maybe Text) -- ^ "value" -  true or false
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MyPrefsShowSidebarMembers
instance A.FromJSON MyPrefsShowSidebarMembers where
  parseJSON = A.withObject "MyPrefsShowSidebarMembers" $ \o ->
    MyPrefsShowSidebarMembers
      <$> (o .:? "value")

-- | ToJSON MyPrefsShowSidebarMembers
instance A.ToJSON MyPrefsShowSidebarMembers where
  toJSON MyPrefsShowSidebarMembers {..} =
   _omitNulls
      [ "value" .= myPrefsShowSidebarMembersValue
      ]


-- | Construct a value of type 'MyPrefsShowSidebarMembers' (by applying it's required fields, if any)
mkMyPrefsShowSidebarMembers
  :: MyPrefsShowSidebarMembers
mkMyPrefsShowSidebarMembers =
  MyPrefsShowSidebarMembers
  { myPrefsShowSidebarMembersValue = Nothing
  }

-- ** Notifications
-- | Notifications
data Notifications = Notifications
  { notificationsUnread :: !(Maybe Text) -- ^ "unread" -  true or false
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Notifications
instance A.FromJSON Notifications where
  parseJSON = A.withObject "Notifications" $ \o ->
    Notifications
      <$> (o .:? "unread")

-- | ToJSON Notifications
instance A.ToJSON Notifications where
  toJSON Notifications {..} =
   _omitNulls
      [ "unread" .= notificationsUnread
      ]


-- | Construct a value of type 'Notifications' (by applying it's required fields, if any)
mkNotifications
  :: Notifications
mkNotifications =
  Notifications
  { notificationsUnread = Nothing
  }

-- ** NotificationsUnread
-- | NotificationsUnread
data NotificationsUnread = NotificationsUnread
  { notificationsUnreadValue :: !(Maybe Text) -- ^ "value" -  true or false
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NotificationsUnread
instance A.FromJSON NotificationsUnread where
  parseJSON = A.withObject "NotificationsUnread" $ \o ->
    NotificationsUnread
      <$> (o .:? "value")

-- | ToJSON NotificationsUnread
instance A.ToJSON NotificationsUnread where
  toJSON NotificationsUnread {..} =
   _omitNulls
      [ "value" .= notificationsUnreadValue
      ]


-- | Construct a value of type 'NotificationsUnread' (by applying it's required fields, if any)
mkNotificationsUnread
  :: NotificationsUnread
mkNotificationsUnread =
  NotificationsUnread
  { notificationsUnreadValue = Nothing
  }

-- ** Organizations
-- | Organizations
data Organizations = Organizations
  { organizationsDesc :: !(Maybe Text) -- ^ "desc" - a string with a length from 0 to 16384
  , organizationsDisplayName :: !(Maybe Text) -- ^ "displayName" - A string with a length of at least 1.  Cannot begin or end with a space.
  , organizationsName :: !(Maybe Text) -- ^ "name" - a string with a length from 0 to 16384
  , organizationsPrefsassociatedDomain :: !(Maybe Text) -- ^ "prefs/associatedDomain" - The google apps domain to link this org to.
  , organizationsPrefsboardVisibilityRestrictorg :: !(Maybe Text) -- ^ "prefs/boardVisibilityRestrict/org" - One of: admin, none or org
  , organizationsPrefsboardVisibilityRestrictprivate :: !(Maybe Text) -- ^ "prefs/boardVisibilityRestrict/private" - One of: admin, none or org
  , organizationsPrefsboardVisibilityRestrictpublic :: !(Maybe Text) -- ^ "prefs/boardVisibilityRestrict/public" - One of: admin, none or org
  , organizationsPrefsexternalMembersDisabled :: !(Maybe Text) -- ^ "prefs/externalMembersDisabled" -  true or false
  , organizationsPrefsgoogleAppsVersion :: !(Maybe Text) -- ^ "prefs/googleAppsVersion" - a number from 1 to 2
  , organizationsPrefsorgInviteRestrict :: !(Maybe Text) -- ^ "prefs/orgInviteRestrict" - An email address with optional expansion tokens
  , organizationsPrefspermissionLevel :: !(Maybe Text) -- ^ "prefs/permissionLevel" - One of: private or public
  , organizationsWebsite :: !(Maybe Text) -- ^ "website" - A URL starting with http:// or https:// or null
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Organizations
instance A.FromJSON Organizations where
  parseJSON = A.withObject "Organizations" $ \o ->
    Organizations
      <$> (o .:? "desc")
      <*> (o .:? "displayName")
      <*> (o .:? "name")
      <*> (o .:? "prefs/associatedDomain")
      <*> (o .:? "prefs/boardVisibilityRestrict/org")
      <*> (o .:? "prefs/boardVisibilityRestrict/private")
      <*> (o .:? "prefs/boardVisibilityRestrict/public")
      <*> (o .:? "prefs/externalMembersDisabled")
      <*> (o .:? "prefs/googleAppsVersion")
      <*> (o .:? "prefs/orgInviteRestrict")
      <*> (o .:? "prefs/permissionLevel")
      <*> (o .:? "website")

-- | ToJSON Organizations
instance A.ToJSON Organizations where
  toJSON Organizations {..} =
   _omitNulls
      [ "desc" .= organizationsDesc
      , "displayName" .= organizationsDisplayName
      , "name" .= organizationsName
      , "prefs/associatedDomain" .= organizationsPrefsassociatedDomain
      , "prefs/boardVisibilityRestrict/org" .= organizationsPrefsboardVisibilityRestrictorg
      , "prefs/boardVisibilityRestrict/private" .= organizationsPrefsboardVisibilityRestrictprivate
      , "prefs/boardVisibilityRestrict/public" .= organizationsPrefsboardVisibilityRestrictpublic
      , "prefs/externalMembersDisabled" .= organizationsPrefsexternalMembersDisabled
      , "prefs/googleAppsVersion" .= organizationsPrefsgoogleAppsVersion
      , "prefs/orgInviteRestrict" .= organizationsPrefsorgInviteRestrict
      , "prefs/permissionLevel" .= organizationsPrefspermissionLevel
      , "website" .= organizationsWebsite
      ]


-- | Construct a value of type 'Organizations' (by applying it's required fields, if any)
mkOrganizations
  :: Organizations
mkOrganizations =
  Organizations
  { organizationsDesc = Nothing
  , organizationsDisplayName = Nothing
  , organizationsName = Nothing
  , organizationsPrefsassociatedDomain = Nothing
  , organizationsPrefsboardVisibilityRestrictorg = Nothing
  , organizationsPrefsboardVisibilityRestrictprivate = Nothing
  , organizationsPrefsboardVisibilityRestrictpublic = Nothing
  , organizationsPrefsexternalMembersDisabled = Nothing
  , organizationsPrefsgoogleAppsVersion = Nothing
  , organizationsPrefsorgInviteRestrict = Nothing
  , organizationsPrefspermissionLevel = Nothing
  , organizationsWebsite = Nothing
  }

-- ** OrganizationsDesc
-- | OrganizationsDesc
data OrganizationsDesc = OrganizationsDesc
  { organizationsDescValue :: !(Maybe Text) -- ^ "value" - a string with a length from 0 to 16384
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OrganizationsDesc
instance A.FromJSON OrganizationsDesc where
  parseJSON = A.withObject "OrganizationsDesc" $ \o ->
    OrganizationsDesc
      <$> (o .:? "value")

-- | ToJSON OrganizationsDesc
instance A.ToJSON OrganizationsDesc where
  toJSON OrganizationsDesc {..} =
   _omitNulls
      [ "value" .= organizationsDescValue
      ]


-- | Construct a value of type 'OrganizationsDesc' (by applying it's required fields, if any)
mkOrganizationsDesc
  :: OrganizationsDesc
mkOrganizationsDesc =
  OrganizationsDesc
  { organizationsDescValue = Nothing
  }

-- ** OrganizationsDisplayName
-- | OrganizationsDisplayName
data OrganizationsDisplayName = OrganizationsDisplayName
  { organizationsDisplayNameValue :: !(Maybe Text) -- ^ "value" - A string with a length of at least 1.  Cannot begin or end with a space.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OrganizationsDisplayName
instance A.FromJSON OrganizationsDisplayName where
  parseJSON = A.withObject "OrganizationsDisplayName" $ \o ->
    OrganizationsDisplayName
      <$> (o .:? "value")

-- | ToJSON OrganizationsDisplayName
instance A.ToJSON OrganizationsDisplayName where
  toJSON OrganizationsDisplayName {..} =
   _omitNulls
      [ "value" .= organizationsDisplayNameValue
      ]


-- | Construct a value of type 'OrganizationsDisplayName' (by applying it's required fields, if any)
mkOrganizationsDisplayName
  :: OrganizationsDisplayName
mkOrganizationsDisplayName =
  OrganizationsDisplayName
  { organizationsDisplayNameValue = Nothing
  }

-- ** OrganizationsLogo
-- | OrganizationsLogo
data OrganizationsLogo = OrganizationsLogo
  { organizationsLogoFile :: !(Maybe Text) -- ^ "file" - A file
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OrganizationsLogo
instance A.FromJSON OrganizationsLogo where
  parseJSON = A.withObject "OrganizationsLogo" $ \o ->
    OrganizationsLogo
      <$> (o .:? "file")

-- | ToJSON OrganizationsLogo
instance A.ToJSON OrganizationsLogo where
  toJSON OrganizationsLogo {..} =
   _omitNulls
      [ "file" .= organizationsLogoFile
      ]


-- | Construct a value of type 'OrganizationsLogo' (by applying it's required fields, if any)
mkOrganizationsLogo
  :: OrganizationsLogo
mkOrganizationsLogo =
  OrganizationsLogo
  { organizationsLogoFile = Nothing
  }

-- ** OrganizationsMembers
-- | OrganizationsMembers
data OrganizationsMembers = OrganizationsMembers
  { organizationsMembersEmail :: !(Maybe Text) -- ^ "email" - An email address
  , organizationsMembersFullName :: !(Maybe Text) -- ^ "fullName" - A string with a length of at least 1.  Cannot begin or end with a space.
  , organizationsMembersType :: !(Maybe Text) -- ^ "type" - One of: admin, normal or observer
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OrganizationsMembers
instance A.FromJSON OrganizationsMembers where
  parseJSON = A.withObject "OrganizationsMembers" $ \o ->
    OrganizationsMembers
      <$> (o .:? "email")
      <*> (o .:? "fullName")
      <*> (o .:? "type")

-- | ToJSON OrganizationsMembers
instance A.ToJSON OrganizationsMembers where
  toJSON OrganizationsMembers {..} =
   _omitNulls
      [ "email" .= organizationsMembersEmail
      , "fullName" .= organizationsMembersFullName
      , "type" .= organizationsMembersType
      ]


-- | Construct a value of type 'OrganizationsMembers' (by applying it's required fields, if any)
mkOrganizationsMembers
  :: OrganizationsMembers
mkOrganizationsMembers =
  OrganizationsMembers
  { organizationsMembersEmail = Nothing
  , organizationsMembersFullName = Nothing
  , organizationsMembersType = Nothing
  }

-- ** OrganizationsMembersDeactivated
-- | OrganizationsMembersDeactivated
data OrganizationsMembersDeactivated = OrganizationsMembersDeactivated
  { organizationsMembersDeactivatedValue :: !(Maybe Text) -- ^ "value" -  true or false
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OrganizationsMembersDeactivated
instance A.FromJSON OrganizationsMembersDeactivated where
  parseJSON = A.withObject "OrganizationsMembersDeactivated" $ \o ->
    OrganizationsMembersDeactivated
      <$> (o .:? "value")

-- | ToJSON OrganizationsMembersDeactivated
instance A.ToJSON OrganizationsMembersDeactivated where
  toJSON OrganizationsMembersDeactivated {..} =
   _omitNulls
      [ "value" .= organizationsMembersDeactivatedValue
      ]


-- | Construct a value of type 'OrganizationsMembersDeactivated' (by applying it's required fields, if any)
mkOrganizationsMembersDeactivated
  :: OrganizationsMembersDeactivated
mkOrganizationsMembersDeactivated =
  OrganizationsMembersDeactivated
  { organizationsMembersDeactivatedValue = Nothing
  }

-- ** OrganizationsMemberships
-- | OrganizationsMemberships
data OrganizationsMemberships = OrganizationsMemberships
  { organizationsMembershipsMemberFields :: !(Maybe Text) -- ^ "member_fields" - all or a comma-separated list of: avatarHash, bio, bioData, confirmed, fullName, idPremOrgsAdmin, initials, memberType, products, status, url or username
  , organizationsMembershipsType :: !(Maybe Text) -- ^ "type" - One of: admin, normal or observer
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OrganizationsMemberships
instance A.FromJSON OrganizationsMemberships where
  parseJSON = A.withObject "OrganizationsMemberships" $ \o ->
    OrganizationsMemberships
      <$> (o .:? "member_fields")
      <*> (o .:? "type")

-- | ToJSON OrganizationsMemberships
instance A.ToJSON OrganizationsMemberships where
  toJSON OrganizationsMemberships {..} =
   _omitNulls
      [ "member_fields" .= organizationsMembershipsMemberFields
      , "type" .= organizationsMembershipsType
      ]


-- | Construct a value of type 'OrganizationsMemberships' (by applying it's required fields, if any)
mkOrganizationsMemberships
  :: OrganizationsMemberships
mkOrganizationsMemberships =
  OrganizationsMemberships
  { organizationsMembershipsMemberFields = Nothing
  , organizationsMembershipsType = Nothing
  }

-- ** OrganizationsName
-- | OrganizationsName
data OrganizationsName = OrganizationsName
  { organizationsNameValue :: !(Maybe Text) -- ^ "value" - A string with a length of at least 3.  Only lowercase letters, underscores, and numbers are allowed.  Must be unique.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OrganizationsName
instance A.FromJSON OrganizationsName where
  parseJSON = A.withObject "OrganizationsName" $ \o ->
    OrganizationsName
      <$> (o .:? "value")

-- | ToJSON OrganizationsName
instance A.ToJSON OrganizationsName where
  toJSON OrganizationsName {..} =
   _omitNulls
      [ "value" .= organizationsNameValue
      ]


-- | Construct a value of type 'OrganizationsName' (by applying it's required fields, if any)
mkOrganizationsName
  :: OrganizationsName
mkOrganizationsName =
  OrganizationsName
  { organizationsNameValue = Nothing
  }

-- ** OrganizationsWebsite
-- | OrganizationsWebsite
data OrganizationsWebsite = OrganizationsWebsite
  { organizationsWebsiteValue :: !(Maybe Text) -- ^ "value" - A URL starting with http:// or https:// or null
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OrganizationsWebsite
instance A.FromJSON OrganizationsWebsite where
  parseJSON = A.withObject "OrganizationsWebsite" $ \o ->
    OrganizationsWebsite
      <$> (o .:? "value")

-- | ToJSON OrganizationsWebsite
instance A.ToJSON OrganizationsWebsite where
  toJSON OrganizationsWebsite {..} =
   _omitNulls
      [ "value" .= organizationsWebsiteValue
      ]


-- | Construct a value of type 'OrganizationsWebsite' (by applying it's required fields, if any)
mkOrganizationsWebsite
  :: OrganizationsWebsite
mkOrganizationsWebsite =
  OrganizationsWebsite
  { organizationsWebsiteValue = Nothing
  }

-- ** PrefsAssociatedDomain
-- | PrefsAssociatedDomain
data PrefsAssociatedDomain = PrefsAssociatedDomain
  { prefsAssociatedDomainValue :: !(Maybe Text) -- ^ "value" - The google apps domain to link this org to.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PrefsAssociatedDomain
instance A.FromJSON PrefsAssociatedDomain where
  parseJSON = A.withObject "PrefsAssociatedDomain" $ \o ->
    PrefsAssociatedDomain
      <$> (o .:? "value")

-- | ToJSON PrefsAssociatedDomain
instance A.ToJSON PrefsAssociatedDomain where
  toJSON PrefsAssociatedDomain {..} =
   _omitNulls
      [ "value" .= prefsAssociatedDomainValue
      ]


-- | Construct a value of type 'PrefsAssociatedDomain' (by applying it's required fields, if any)
mkPrefsAssociatedDomain
  :: PrefsAssociatedDomain
mkPrefsAssociatedDomain =
  PrefsAssociatedDomain
  { prefsAssociatedDomainValue = Nothing
  }

-- ** PrefsBackground
-- | PrefsBackground
data PrefsBackground = PrefsBackground
  { prefsBackgroundValue :: !(Maybe Text) -- ^ "value" - A standard background name, or the id of a custom background
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PrefsBackground
instance A.FromJSON PrefsBackground where
  parseJSON = A.withObject "PrefsBackground" $ \o ->
    PrefsBackground
      <$> (o .:? "value")

-- | ToJSON PrefsBackground
instance A.ToJSON PrefsBackground where
  toJSON PrefsBackground {..} =
   _omitNulls
      [ "value" .= prefsBackgroundValue
      ]


-- | Construct a value of type 'PrefsBackground' (by applying it's required fields, if any)
mkPrefsBackground
  :: PrefsBackground
mkPrefsBackground =
  PrefsBackground
  { prefsBackgroundValue = Nothing
  }

-- ** PrefsBoardVisibilityRestrict
-- | PrefsBoardVisibilityRestrict
data PrefsBoardVisibilityRestrict = PrefsBoardVisibilityRestrict
  { prefsBoardVisibilityRestrictValue :: !(Maybe Text) -- ^ "value" - One of: admin, none or org
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PrefsBoardVisibilityRestrict
instance A.FromJSON PrefsBoardVisibilityRestrict where
  parseJSON = A.withObject "PrefsBoardVisibilityRestrict" $ \o ->
    PrefsBoardVisibilityRestrict
      <$> (o .:? "value")

-- | ToJSON PrefsBoardVisibilityRestrict
instance A.ToJSON PrefsBoardVisibilityRestrict where
  toJSON PrefsBoardVisibilityRestrict {..} =
   _omitNulls
      [ "value" .= prefsBoardVisibilityRestrictValue
      ]


-- | Construct a value of type 'PrefsBoardVisibilityRestrict' (by applying it's required fields, if any)
mkPrefsBoardVisibilityRestrict
  :: PrefsBoardVisibilityRestrict
mkPrefsBoardVisibilityRestrict =
  PrefsBoardVisibilityRestrict
  { prefsBoardVisibilityRestrictValue = Nothing
  }

-- ** PrefsCalendarFeedEnabled
-- | PrefsCalendarFeedEnabled
data PrefsCalendarFeedEnabled = PrefsCalendarFeedEnabled
  { prefsCalendarFeedEnabledValue :: !(Maybe Text) -- ^ "value" -  true or false
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PrefsCalendarFeedEnabled
instance A.FromJSON PrefsCalendarFeedEnabled where
  parseJSON = A.withObject "PrefsCalendarFeedEnabled" $ \o ->
    PrefsCalendarFeedEnabled
      <$> (o .:? "value")

-- | ToJSON PrefsCalendarFeedEnabled
instance A.ToJSON PrefsCalendarFeedEnabled where
  toJSON PrefsCalendarFeedEnabled {..} =
   _omitNulls
      [ "value" .= prefsCalendarFeedEnabledValue
      ]


-- | Construct a value of type 'PrefsCalendarFeedEnabled' (by applying it's required fields, if any)
mkPrefsCalendarFeedEnabled
  :: PrefsCalendarFeedEnabled
mkPrefsCalendarFeedEnabled =
  PrefsCalendarFeedEnabled
  { prefsCalendarFeedEnabledValue = Nothing
  }

-- ** PrefsCardAging
-- | PrefsCardAging
data PrefsCardAging = PrefsCardAging
  { prefsCardAgingValue :: !(Maybe Text) -- ^ "value" - One of: pirate or regular
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PrefsCardAging
instance A.FromJSON PrefsCardAging where
  parseJSON = A.withObject "PrefsCardAging" $ \o ->
    PrefsCardAging
      <$> (o .:? "value")

-- | ToJSON PrefsCardAging
instance A.ToJSON PrefsCardAging where
  toJSON PrefsCardAging {..} =
   _omitNulls
      [ "value" .= prefsCardAgingValue
      ]


-- | Construct a value of type 'PrefsCardAging' (by applying it's required fields, if any)
mkPrefsCardAging
  :: PrefsCardAging
mkPrefsCardAging =
  PrefsCardAging
  { prefsCardAgingValue = Nothing
  }

-- ** PrefsCardCovers
-- | PrefsCardCovers
data PrefsCardCovers = PrefsCardCovers
  { prefsCardCoversValue :: !(Maybe Text) -- ^ "value" -  true or false
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PrefsCardCovers
instance A.FromJSON PrefsCardCovers where
  parseJSON = A.withObject "PrefsCardCovers" $ \o ->
    PrefsCardCovers
      <$> (o .:? "value")

-- | ToJSON PrefsCardCovers
instance A.ToJSON PrefsCardCovers where
  toJSON PrefsCardCovers {..} =
   _omitNulls
      [ "value" .= prefsCardCoversValue
      ]


-- | Construct a value of type 'PrefsCardCovers' (by applying it's required fields, if any)
mkPrefsCardCovers
  :: PrefsCardCovers
mkPrefsCardCovers =
  PrefsCardCovers
  { prefsCardCoversValue = Nothing
  }

-- ** PrefsColorBlind
-- | PrefsColorBlind
data PrefsColorBlind = PrefsColorBlind
  { prefsColorBlindValue :: !(Maybe Text) -- ^ "value" -  true or false
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PrefsColorBlind
instance A.FromJSON PrefsColorBlind where
  parseJSON = A.withObject "PrefsColorBlind" $ \o ->
    PrefsColorBlind
      <$> (o .:? "value")

-- | ToJSON PrefsColorBlind
instance A.ToJSON PrefsColorBlind where
  toJSON PrefsColorBlind {..} =
   _omitNulls
      [ "value" .= prefsColorBlindValue
      ]


-- | Construct a value of type 'PrefsColorBlind' (by applying it's required fields, if any)
mkPrefsColorBlind
  :: PrefsColorBlind
mkPrefsColorBlind =
  PrefsColorBlind
  { prefsColorBlindValue = Nothing
  }

-- ** PrefsComments
-- | PrefsComments
data PrefsComments = PrefsComments
  { prefsCommentsValue :: !(Maybe Text) -- ^ "value" - One of: disabled, members, observers, org or public
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PrefsComments
instance A.FromJSON PrefsComments where
  parseJSON = A.withObject "PrefsComments" $ \o ->
    PrefsComments
      <$> (o .:? "value")

-- | ToJSON PrefsComments
instance A.ToJSON PrefsComments where
  toJSON PrefsComments {..} =
   _omitNulls
      [ "value" .= prefsCommentsValue
      ]


-- | Construct a value of type 'PrefsComments' (by applying it's required fields, if any)
mkPrefsComments
  :: PrefsComments
mkPrefsComments =
  PrefsComments
  { prefsCommentsValue = Nothing
  }

-- ** PrefsExternalMembersDisabled
-- | PrefsExternalMembersDisabled
data PrefsExternalMembersDisabled = PrefsExternalMembersDisabled
  { prefsExternalMembersDisabledValue :: !(Maybe Text) -- ^ "value" -  true or false
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PrefsExternalMembersDisabled
instance A.FromJSON PrefsExternalMembersDisabled where
  parseJSON = A.withObject "PrefsExternalMembersDisabled" $ \o ->
    PrefsExternalMembersDisabled
      <$> (o .:? "value")

-- | ToJSON PrefsExternalMembersDisabled
instance A.ToJSON PrefsExternalMembersDisabled where
  toJSON PrefsExternalMembersDisabled {..} =
   _omitNulls
      [ "value" .= prefsExternalMembersDisabledValue
      ]


-- | Construct a value of type 'PrefsExternalMembersDisabled' (by applying it's required fields, if any)
mkPrefsExternalMembersDisabled
  :: PrefsExternalMembersDisabled
mkPrefsExternalMembersDisabled =
  PrefsExternalMembersDisabled
  { prefsExternalMembersDisabledValue = Nothing
  }

-- ** PrefsGoogleAppsVersion
-- | PrefsGoogleAppsVersion
data PrefsGoogleAppsVersion = PrefsGoogleAppsVersion
  { prefsGoogleAppsVersionValue :: !(Maybe Text) -- ^ "value" - a number from 1 to 2
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PrefsGoogleAppsVersion
instance A.FromJSON PrefsGoogleAppsVersion where
  parseJSON = A.withObject "PrefsGoogleAppsVersion" $ \o ->
    PrefsGoogleAppsVersion
      <$> (o .:? "value")

-- | ToJSON PrefsGoogleAppsVersion
instance A.ToJSON PrefsGoogleAppsVersion where
  toJSON PrefsGoogleAppsVersion {..} =
   _omitNulls
      [ "value" .= prefsGoogleAppsVersionValue
      ]


-- | Construct a value of type 'PrefsGoogleAppsVersion' (by applying it's required fields, if any)
mkPrefsGoogleAppsVersion
  :: PrefsGoogleAppsVersion
mkPrefsGoogleAppsVersion =
  PrefsGoogleAppsVersion
  { prefsGoogleAppsVersionValue = Nothing
  }

-- ** PrefsInvitations
-- | PrefsInvitations
data PrefsInvitations = PrefsInvitations
  { prefsInvitationsValue :: !(Maybe Text) -- ^ "value" - One of: admins or members
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PrefsInvitations
instance A.FromJSON PrefsInvitations where
  parseJSON = A.withObject "PrefsInvitations" $ \o ->
    PrefsInvitations
      <$> (o .:? "value")

-- | ToJSON PrefsInvitations
instance A.ToJSON PrefsInvitations where
  toJSON PrefsInvitations {..} =
   _omitNulls
      [ "value" .= prefsInvitationsValue
      ]


-- | Construct a value of type 'PrefsInvitations' (by applying it's required fields, if any)
mkPrefsInvitations
  :: PrefsInvitations
mkPrefsInvitations =
  PrefsInvitations
  { prefsInvitationsValue = Nothing
  }

-- ** PrefsLocale
-- | PrefsLocale
data PrefsLocale = PrefsLocale
  { prefsLocaleValue :: !(Maybe Text) -- ^ "value" - a string with a length from 0 to 255
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PrefsLocale
instance A.FromJSON PrefsLocale where
  parseJSON = A.withObject "PrefsLocale" $ \o ->
    PrefsLocale
      <$> (o .:? "value")

-- | ToJSON PrefsLocale
instance A.ToJSON PrefsLocale where
  toJSON PrefsLocale {..} =
   _omitNulls
      [ "value" .= prefsLocaleValue
      ]


-- | Construct a value of type 'PrefsLocale' (by applying it's required fields, if any)
mkPrefsLocale
  :: PrefsLocale
mkPrefsLocale =
  PrefsLocale
  { prefsLocaleValue = Nothing
  }

-- ** PrefsMinutesBetweenSummaries
-- | PrefsMinutesBetweenSummaries
data PrefsMinutesBetweenSummaries = PrefsMinutesBetweenSummaries
  { prefsMinutesBetweenSummariesValue :: !(Maybe Text) -- ^ "value" - -1 (disabled), 1 or 60
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PrefsMinutesBetweenSummaries
instance A.FromJSON PrefsMinutesBetweenSummaries where
  parseJSON = A.withObject "PrefsMinutesBetweenSummaries" $ \o ->
    PrefsMinutesBetweenSummaries
      <$> (o .:? "value")

-- | ToJSON PrefsMinutesBetweenSummaries
instance A.ToJSON PrefsMinutesBetweenSummaries where
  toJSON PrefsMinutesBetweenSummaries {..} =
   _omitNulls
      [ "value" .= prefsMinutesBetweenSummariesValue
      ]


-- | Construct a value of type 'PrefsMinutesBetweenSummaries' (by applying it's required fields, if any)
mkPrefsMinutesBetweenSummaries
  :: PrefsMinutesBetweenSummaries
mkPrefsMinutesBetweenSummaries =
  PrefsMinutesBetweenSummaries
  { prefsMinutesBetweenSummariesValue = Nothing
  }

-- ** PrefsOrgInviteRestrict
-- | PrefsOrgInviteRestrict
data PrefsOrgInviteRestrict = PrefsOrgInviteRestrict
  { prefsOrgInviteRestrictValue :: !(Maybe Text) -- ^ "value" - An email address with optional expansion tokens
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PrefsOrgInviteRestrict
instance A.FromJSON PrefsOrgInviteRestrict where
  parseJSON = A.withObject "PrefsOrgInviteRestrict" $ \o ->
    PrefsOrgInviteRestrict
      <$> (o .:? "value")

-- | ToJSON PrefsOrgInviteRestrict
instance A.ToJSON PrefsOrgInviteRestrict where
  toJSON PrefsOrgInviteRestrict {..} =
   _omitNulls
      [ "value" .= prefsOrgInviteRestrictValue
      ]


-- | Construct a value of type 'PrefsOrgInviteRestrict' (by applying it's required fields, if any)
mkPrefsOrgInviteRestrict
  :: PrefsOrgInviteRestrict
mkPrefsOrgInviteRestrict =
  PrefsOrgInviteRestrict
  { prefsOrgInviteRestrictValue = Nothing
  }

-- ** PrefsPermissionLevel
-- | PrefsPermissionLevel
data PrefsPermissionLevel = PrefsPermissionLevel
  { prefsPermissionLevelValue :: !(Maybe Text) -- ^ "value" - One of: private or public
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PrefsPermissionLevel
instance A.FromJSON PrefsPermissionLevel where
  parseJSON = A.withObject "PrefsPermissionLevel" $ \o ->
    PrefsPermissionLevel
      <$> (o .:? "value")

-- | ToJSON PrefsPermissionLevel
instance A.ToJSON PrefsPermissionLevel where
  toJSON PrefsPermissionLevel {..} =
   _omitNulls
      [ "value" .= prefsPermissionLevelValue
      ]


-- | Construct a value of type 'PrefsPermissionLevel' (by applying it's required fields, if any)
mkPrefsPermissionLevel
  :: PrefsPermissionLevel
mkPrefsPermissionLevel =
  PrefsPermissionLevel
  { prefsPermissionLevelValue = Nothing
  }

-- ** PrefsSelfJoin
-- | PrefsSelfJoin
data PrefsSelfJoin = PrefsSelfJoin
  { prefsSelfJoinValue :: !(Maybe Text) -- ^ "value" -  true or false
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PrefsSelfJoin
instance A.FromJSON PrefsSelfJoin where
  parseJSON = A.withObject "PrefsSelfJoin" $ \o ->
    PrefsSelfJoin
      <$> (o .:? "value")

-- | ToJSON PrefsSelfJoin
instance A.ToJSON PrefsSelfJoin where
  toJSON PrefsSelfJoin {..} =
   _omitNulls
      [ "value" .= prefsSelfJoinValue
      ]


-- | Construct a value of type 'PrefsSelfJoin' (by applying it's required fields, if any)
mkPrefsSelfJoin
  :: PrefsSelfJoin
mkPrefsSelfJoin =
  PrefsSelfJoin
  { prefsSelfJoinValue = Nothing
  }

-- ** PrefsVoting
-- | PrefsVoting
data PrefsVoting = PrefsVoting
  { prefsVotingValue :: !(Maybe Text) -- ^ "value" - One of: disabled, members, observers, org or public
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PrefsVoting
instance A.FromJSON PrefsVoting where
  parseJSON = A.withObject "PrefsVoting" $ \o ->
    PrefsVoting
      <$> (o .:? "value")

-- | ToJSON PrefsVoting
instance A.ToJSON PrefsVoting where
  toJSON PrefsVoting {..} =
   _omitNulls
      [ "value" .= prefsVotingValue
      ]


-- | Construct a value of type 'PrefsVoting' (by applying it's required fields, if any)
mkPrefsVoting
  :: PrefsVoting
mkPrefsVoting =
  PrefsVoting
  { prefsVotingValue = Nothing
  }

-- ** Sessions
-- | Sessions
data Sessions = Sessions
  { sessionsIdBoard :: !(Maybe Text) -- ^ "idBoard" - The id of the board you&amp;#39;re viewing.  Boards with no viewers will not get updates about members&amp;#39; statuses.
  , sessionsStatus :: !(Maybe Text) -- ^ "status" - One of: active, disconnected or idle
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Sessions
instance A.FromJSON Sessions where
  parseJSON = A.withObject "Sessions" $ \o ->
    Sessions
      <$> (o .:? "idBoard")
      <*> (o .:? "status")

-- | ToJSON Sessions
instance A.ToJSON Sessions where
  toJSON Sessions {..} =
   _omitNulls
      [ "idBoard" .= sessionsIdBoard
      , "status" .= sessionsStatus
      ]


-- | Construct a value of type 'Sessions' (by applying it's required fields, if any)
mkSessions
  :: Sessions
mkSessions =
  Sessions
  { sessionsIdBoard = Nothing
  , sessionsStatus = Nothing
  }

-- ** SessionsStatus
-- | SessionsStatus
data SessionsStatus = SessionsStatus
  { sessionsStatusValue :: !(Maybe Text) -- ^ "value" - One of: active, disconnected or idle
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SessionsStatus
instance A.FromJSON SessionsStatus where
  parseJSON = A.withObject "SessionsStatus" $ \o ->
    SessionsStatus
      <$> (o .:? "value")

-- | ToJSON SessionsStatus
instance A.ToJSON SessionsStatus where
  toJSON SessionsStatus {..} =
   _omitNulls
      [ "value" .= sessionsStatusValue
      ]


-- | Construct a value of type 'SessionsStatus' (by applying it's required fields, if any)
mkSessionsStatus
  :: SessionsStatus
mkSessionsStatus =
  SessionsStatus
  { sessionsStatusValue = Nothing
  }

-- ** TokensWebhooks
-- | TokensWebhooks
data TokensWebhooks = TokensWebhooks
  { tokensWebhooksCallbackUrl :: !(Maybe Text) -- ^ "callbackURL" - A valid URL that is reachable with a HEAD request
  , tokensWebhooksDescription :: !(Maybe Text) -- ^ "description" - a string with a length from 0 to 16384
  , tokensWebhooksIdModel :: !(Maybe Text) -- ^ "idModel" - id of the model to be monitored
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TokensWebhooks
instance A.FromJSON TokensWebhooks where
  parseJSON = A.withObject "TokensWebhooks" $ \o ->
    TokensWebhooks
      <$> (o .:? "callbackURL")
      <*> (o .:? "description")
      <*> (o .:? "idModel")

-- | ToJSON TokensWebhooks
instance A.ToJSON TokensWebhooks where
  toJSON TokensWebhooks {..} =
   _omitNulls
      [ "callbackURL" .= tokensWebhooksCallbackUrl
      , "description" .= tokensWebhooksDescription
      , "idModel" .= tokensWebhooksIdModel
      ]


-- | Construct a value of type 'TokensWebhooks' (by applying it's required fields, if any)
mkTokensWebhooks
  :: TokensWebhooks
mkTokensWebhooks =
  TokensWebhooks
  { tokensWebhooksCallbackUrl = Nothing
  , tokensWebhooksDescription = Nothing
  , tokensWebhooksIdModel = Nothing
  }

-- ** Webhooks
-- | Webhooks
data Webhooks = Webhooks
  { webhooksActive :: !(Maybe Text) -- ^ "active" -  true or false
  , webhooksCallbackUrl :: !(Maybe Text) -- ^ "callbackURL" - A valid URL that is reachable with a HEAD request
  , webhooksDescription :: !(Maybe Text) -- ^ "description" - a string with a length from 0 to 16384
  , webhooksIdModel :: !(Maybe Text) -- ^ "idModel" - id of the model that should be hooked
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Webhooks
instance A.FromJSON Webhooks where
  parseJSON = A.withObject "Webhooks" $ \o ->
    Webhooks
      <$> (o .:? "active")
      <*> (o .:? "callbackURL")
      <*> (o .:? "description")
      <*> (o .:? "idModel")

-- | ToJSON Webhooks
instance A.ToJSON Webhooks where
  toJSON Webhooks {..} =
   _omitNulls
      [ "active" .= webhooksActive
      , "callbackURL" .= webhooksCallbackUrl
      , "description" .= webhooksDescription
      , "idModel" .= webhooksIdModel
      ]


-- | Construct a value of type 'Webhooks' (by applying it's required fields, if any)
mkWebhooks
  :: Webhooks
mkWebhooks =
  Webhooks
  { webhooksActive = Nothing
  , webhooksCallbackUrl = Nothing
  , webhooksDescription = Nothing
  , webhooksIdModel = Nothing
  }

-- ** WebhooksActive
-- | WebhooksActive
data WebhooksActive = WebhooksActive
  { webhooksActiveValue :: !(Maybe Text) -- ^ "value" -  true or false
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON WebhooksActive
instance A.FromJSON WebhooksActive where
  parseJSON = A.withObject "WebhooksActive" $ \o ->
    WebhooksActive
      <$> (o .:? "value")

-- | ToJSON WebhooksActive
instance A.ToJSON WebhooksActive where
  toJSON WebhooksActive {..} =
   _omitNulls
      [ "value" .= webhooksActiveValue
      ]


-- | Construct a value of type 'WebhooksActive' (by applying it's required fields, if any)
mkWebhooksActive
  :: WebhooksActive
mkWebhooksActive =
  WebhooksActive
  { webhooksActiveValue = Nothing
  }

-- ** WebhooksCallbackURL
-- | WebhooksCallbackURL
data WebhooksCallbackURL = WebhooksCallbackURL
  { webhooksCallbackURLValue :: !(Maybe Text) -- ^ "value" - A valid URL that is reachable with a HEAD request
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON WebhooksCallbackURL
instance A.FromJSON WebhooksCallbackURL where
  parseJSON = A.withObject "WebhooksCallbackURL" $ \o ->
    WebhooksCallbackURL
      <$> (o .:? "value")

-- | ToJSON WebhooksCallbackURL
instance A.ToJSON WebhooksCallbackURL where
  toJSON WebhooksCallbackURL {..} =
   _omitNulls
      [ "value" .= webhooksCallbackURLValue
      ]


-- | Construct a value of type 'WebhooksCallbackURL' (by applying it's required fields, if any)
mkWebhooksCallbackURL
  :: WebhooksCallbackURL
mkWebhooksCallbackURL =
  WebhooksCallbackURL
  { webhooksCallbackURLValue = Nothing
  }

-- ** WebhooksDescription
-- | WebhooksDescription
data WebhooksDescription = WebhooksDescription
  { webhooksDescriptionValue :: !(Maybe Text) -- ^ "value" - a string with a length from 0 to 16384
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON WebhooksDescription
instance A.FromJSON WebhooksDescription where
  parseJSON = A.withObject "WebhooksDescription" $ \o ->
    WebhooksDescription
      <$> (o .:? "value")

-- | ToJSON WebhooksDescription
instance A.ToJSON WebhooksDescription where
  toJSON WebhooksDescription {..} =
   _omitNulls
      [ "value" .= webhooksDescriptionValue
      ]


-- | Construct a value of type 'WebhooksDescription' (by applying it's required fields, if any)
mkWebhooksDescription
  :: WebhooksDescription
mkWebhooksDescription =
  WebhooksDescription
  { webhooksDescriptionValue = Nothing
  }

-- ** WebhooksIdModel
-- | WebhooksIdModel
data WebhooksIdModel = WebhooksIdModel
  { webhooksIdModelValue :: !(Maybe Text) -- ^ "value" - id of the model to be monitored
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON WebhooksIdModel
instance A.FromJSON WebhooksIdModel where
  parseJSON = A.withObject "WebhooksIdModel" $ \o ->
    WebhooksIdModel
      <$> (o .:? "value")

-- | ToJSON WebhooksIdModel
instance A.ToJSON WebhooksIdModel where
  toJSON WebhooksIdModel {..} =
   _omitNulls
      [ "value" .= webhooksIdModelValue
      ]


-- | Construct a value of type 'WebhooksIdModel' (by applying it's required fields, if any)
mkWebhooksIdModel
  :: WebhooksIdModel
mkWebhooksIdModel =
  WebhooksIdModel
  { webhooksIdModelValue = Nothing
  }




-- * Auth Methods

-- ** AuthApiKeyApiKey
data AuthApiKeyApiKey =
  AuthApiKeyApiKey Text -- ^ secret
  deriving (P.Eq, P.Show, P.Typeable)

instance AuthMethod AuthApiKeyApiKey where
  applyAuthMethod _ a@(AuthApiKeyApiKey secret) req =
    P.pure $
    if (P.typeOf a `P.elem` rAuthTypes req)
      then req `setQuery` toQuery ("key", Just secret)
           & L.over rAuthTypesL (P.filter (/= P.typeOf a))
      else req

-- ** AuthApiKeyApiToken
data AuthApiKeyApiToken =
  AuthApiKeyApiToken Text -- ^ secret
  deriving (P.Eq, P.Show, P.Typeable)

instance AuthMethod AuthApiKeyApiToken where
  applyAuthMethod _ a@(AuthApiKeyApiToken secret) req =
    P.pure $
    if (P.typeOf a `P.elem` rAuthTypes req)
      then req `setQuery` toQuery ("token", Just secret)
           & L.over rAuthTypesL (P.filter (/= P.typeOf a))
      else req

